<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨专业考研历程]]></title>
    <url>%2F2019%2F04%2F06%2F%E8%B7%A8%E4%B8%93%E4%B8%9A%E8%80%83%E7%A0%94%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[跨专业考研历程​ 这篇文章很长，原文更长，是在原文的基础上我删减了些内容贴上来的(因为有些东西不想被看到，哈哈哈） ​ 从出结果到现在已经5天了，回顾起从去年3月份到现在，从头铁跨考到迟疑放弃，9月份之后的复习心情一度十分沉重，临近考试前更是觉得准备的不够充分就马上上考场，考完数学心态爆炸，觉得可能一年的努力已经化为泡影了。而当天下午的专业课带给我了希望。休息了一周开始准备机试，期待着机试能够逆袭。浑浑噩噩刷着PAT乙和历年AB题，不知不觉就放假回家了。在家里根本学不下去，又慌又不得不继续复习。然后出成绩给了我特大的惊喜，崩塌的数学在较松的阅卷之下还能达到120+。原来并不看好的英语竟然75。专业课压分在意料之中，原来计划的目标是380，本以为已经无望，总分竟然达到了380+，虽说面试不太好，但分高终究是上岸了，而后几天开始放松，体检前一天骑着单车去办工行卡，迎着微风，阳光正好，世界真美好！ ​ 这一年考研的历程对我来说是十分宝贵的一段经历，路是自己选的，未来的专业也是自己追求的，人生中似乎第一次自己挑战困难，克服自己的得过且过的思想，克服自己懒散的思想，开始觉得人生必须有自己的追求，必须有自己喜欢并且为之奋斗努力的事情改变 — 以前似乎并不明白，现在似乎懂了一点。认识自己，了解自己的追求，勇于克服困难，坚持不懈！这是我这一年里最大的收获。 备考初期​ 3月份开学，身边的人有的已经决定考研，有的已经全力准备工作，有的为出国从大一开学就开始计划，似乎自己还处在一个浑浑噩噩的状态，不知道要干嘛，对本专业无感，喜欢计算机却惧怕困难，止步不前。导致在决定跨考的时候还是0计算机经历，连基本的编程语言也不会。当时一个随意的决定，“要不我尝试着考考吧，到时候复习的不行就考本院管工，专业课也学过”。我就是以这样的一个心态开始自己的考研之路的。 ​ 初期，当然是看各种经验贴，跟着17年网管420+的大佬的经验贴学习，看北邮论坛上的考研专刊。在决定买哪一本资料的时候，看到所有的经验贴几乎都提到了同一个数学老师——张宇。于是上京东搜张宇，刚好高数线代概率一套，其实我也知道更多的是只用张宇高数的，我就有点小小的强迫症了，我要买封面长得一样的(很SB有木有)，简直是自己坑自己啊先不吐槽张宇了(喵喵喵???)。然后跟着做张宇的36讲，哇，这啥题啊，例题一个都不会，这不看答案怎么做的出来嘛！，二重积分咋积啊，三重积分曲面积分曲线积分不会，跳过了，高数看完了！！！开始线代，哇，行列式啥玩意，技巧这么多，这玩意我学的时候都是只算过三阶行列式斜着乘然后加减就完事了，这咋还要化简呢？矩阵的秩啥玩意啊，这矩阵秩的公式我咋理解不了。矩阵秩不会，跳过了。来到方程组，还好学过一点记得啥是基础解系。后面对角化，对称矩阵的内容，张宇的书根本就讲不清楚，向量与秩这一章充斥着大量的证明题，这我怎么会嘛？概率也是跟高数线代一样，属于完全懵逼的状态，只记得标题学过，题目一个都不会(所以我大学数一相关课60+不是没有道理的，再次笑话自己一波)。 ​ 英语复习呢，看到经验贴上有人用红宝书，红色封面(还挺喜欢的)，没多想就买了，开始迎着头皮背单词(然而我又把自己坑了)，这书不吐槽了，单词实在太多了，很多单词根本就记不住，根本就不考。傻乎乎的背了3个月单词，开始做了几年真题，立马把单词书扔在一旁了。做阅读的时候，我这渣渣的英语水平，单词还停留在高中水平，不，大学的英语明明在退步，还达不到高考水平，有次英语一篇阅读24分钟错4个，一张卷子下来做10多个，这英语水平垃圾成这样，考研英语怎么过线嘛？于是准备找将阅读的视频看，直到后来，无意中看了眼考研群，有人说唐迟的阅读讲的好，于是看了唐迟2006年A篇阅读，对阅读逻辑的一个总结。哇，当时就觉得，这个老师实在是讲的太好了，这就是我想听的，于是后来阅读全程跟唐迟，阅读的准确率提高了不少，后来唐迟在视频里推他自己写的书，为了表示谢意，我买了一本表示支持，不过到后来也没有看，因为后来阅读已经错的很少了，不超过3个，所以就翻了一下，还崭新的没看过，看有机会送人吧。对于阅读的新题型，看到考研的经验贴说，“新题型太简单了”，“新题型做了几天，不难，重点要放在阅读上”，所以我的新题型，从很晚才开始看，大概11月吧，那时候，我阅读错3个，新题型至少错3个？我开始慌了，新题型啥玩意，7选5也太难了吧，我咋感觉这段话放哪都可以啊，后来也是找网课看，网课中东西，实在是太多了，质量参差不齐，每个老师讲的方法也不一样，侧重点也不一样。唐迟讲的也不如阅读那样出彩。 ​ 再来说说专业课，专业课从4月份开始看王道，顺序是数据结构 &gt;&gt; 组成原理 &gt;&gt; 操作系统 &gt;&gt; 计算机网络。数据结构第一遍复习的时候，把算法题跳过去了还是蛮简单的，王道上的数据结构更多的是手动的模拟，栈啊，树遍历啊，图的深度优先，广度优先，四大应用，手动模拟还是蛮简单的。于是一个月多一点数据结构第一遍复习完了。不觉得这玩意对于跨考有多大的困难(只因为把全部的算法题跳过去了)。 ​ 后来开始看组成原理，简直是噩梦般的组成原理，当年辅修的时候上课就一句没听懂过，白日英的书籍全是图，文字就像他自己学习时做的笔记一样，于是在网上又买了唐朔飞的组成原理书，这书比白书要友好很多。不过章节编排上与王道不太一样，后来就是看王道目录，找唐书对应章节看，看完然后在看王道上的总结，之后在做题，所以在组成原理绝大部分的时间都留在了看书上，王道上组成原理的408真题在我第一遍刚做时觉得相当变态，基本上就是第一遍自己做根本做不出来，然后答案也看不太懂，主存与CPU的连接电路根本不知道啥玩意，没有学过数电，也不知道译码器，片选信号是咋来的，后来找了文都的视频看，才慢慢看懂。组成原理就是这样对着课本看，对着视频看才解决了。 ​ 操作系统，这门课只有进程的PV在第一次学的时候不知道啥玩意，内存这一章在组原里学过，所以很快就解决了，后面文件，设备，都不难。我的顺序的跳过进程管理这一章，把王道上的题目看完才开始看进程管理。PV也是对着文都的视频看(反正遇到太难的自己解决不了就找视频看)。学完PV后，再做王道课后408的PV题，送分题，这分我要了！！！ ​ 计算机网络，这课我学过(手动滑稽)，犹记得当年辅修计算机网络的时候，wxr老师教的网络课，大概35不到，微胖。当时期中考试，我第一题HDLC组帧的题就不会，空在那里。“这张卷子是谁的，第1题我不是上课讲过吗？XXX在吗？过来一下”， 我过去了，“这题我上课不是讲过吗，怎么这也不会”， “老师，我辅修的，上节课没来(其实我来了，只是我上课全程玩手机)”，“哦，辅修的是吧”，然后开始巴拉巴拉，开始讲给我讲解知识点，“你拿回去改一下再交上来吧”，我愣了一下，“老师这不是期中考试吗？还能拿回去再做的吗？”，“没事，会了就行”，然后我拿回去改，其实我没听太懂，不会，听懂了一点，然后开始按着的我错误的思路，写上交了上去，交上去老师按了一眼，“做错了，拿回去重做吧”，我心里想，“我不会啊，这中午是走不了吗？”然后看到其他人的卷子，让他给我抄一下，交上去了。诶，现在想来，当时实在是太菜了，数5个1去掉后面一个0，然后转为16进制有啥子难的，当时辅修的态度实在是太不端正了，完全就是混。不过我还蛮喜欢这老师的，老师帮助我们期末复习超级认真的，我本科就没见过这么认真的老师，课程没有上完就就录音复习，给了我们完整的试题和复习资料，所有的习题都有答案和老师的录音讲解。本来考研计划考这老师的研究生的，后来考研群群主各种宣传网研，于是决定不考计算机学院了，我还是选择稳一手，选个好考的考。既然开始写了辅修的经历，还是继续写下去吧，这段经历虽然说自己是水过去了，但是现在回忆起来，也好过我上过的绝大多数课程。 备考中期​ 来到9月份，数学第一轮也差不多结束，专业课也差不多第一轮结束。虽说离自己的计划有点区别出入，但由于一个月的实习，我能完成这些自认为已经很不错了。这个时候，我开始做1000题，这是最大的错误，1000题上几乎全部是老题，各种重复题型的胡乱堆砌，我又是那种不喜欢看答案的，我觉得我能做，但总是算错，所以这段时间的复习相当痛苦，我一早上只能做5道大题，其中还包括作了半个多小时还做错的。到了10月中旬才开始做真题，一天一套，这个时候做了真题才知道什么是重点，什么是要学的，考研考察什么，哪些题目是不用做的，哪些题目是需要直接放弃的。 ​ 回归真题，真题用的是张宇的真题大全解，87-18年32年真题，前面87-03年是100分的卷子，题目蛮简单，但是做的很差，计算错误一大堆。每次做完真题觉得自己怎么这么SB，“这简单的也能错？”。03做完一个阶段之后整理一下错题，然后买了40元钱的答题卡(当然买太多了最后用不完)。04-18年的题目拿来模拟，一样的情况，做完想剁手，直到15年之后的试卷，准确率也练出来了。基本均分130+，后面自信也基本找出来了。于是开始做模拟题，浪费了一个星期时间做张宇八套卷，然后网上买了合工大超越卷 (听说这卷子不错)，的确，超越卷的质量非常好，题目思路很新颖，需要动脑子想，思路想清楚了就简单，不像张宇的，大多是老题，一个填空题一看就会做，一做半个小时算不出来，纯粹浪费时间。合工大的当年的卷子出的很晚，直到12月上旬出的，共创卷中旬才出，我全部拿过来做了一下。超越卷的难度史无前有，超越了张宇8套卷，非常之难。共创相比就人性化很多。真题模拟题做完之后就没事干了，看看自己做的错题，之后就上考场了。 ​ 9月份之后的专业课来到第二轮复习。数据结构的算法题成了最硬的骨头，因为我知道16年的算法题是15分，我想，如果我做不出来这道题，按照803的压分程度，我应该是1分也拿不到。所以，我一定要把这道题给啃下来。这个时候，一轮复习的题目重新做了一遍，因为当时一轮复习没有用铅笔写，所以答案都写在上面，最后二轮复习的进度很快。408的计组第二遍复习一句很难，做过一遍的题还是不会做，但是在第二遍做的过程中，理解更加深入了。另外两门课最水，11月中旬，二轮复习专业课全部结束。但是算法题还是不会，线性表的题全部会了，但是树和图的算法题还是不会。外部排序直接放弃了，803目前还没有考过，只知道外部排序用归并排序就可以了。计组已经基本上全部理解了，就刷题慢，不熟练。于是11中旬开始啃树和图的算法题。啃了一个星期，树和图找了文都的视频看，王道数据结构视频由于贴合408风格，所以基本上没有树和图的算法知识。把文都视频上算法慢慢听，然后手抄了一遍。其实把遍历弄懂就基本就会了，树的算法很多都是基于遍历的。基本上把课本上所有出现的算法抄了一遍，抄了两个薄薄的本子。所以算法也基本上克服了。这部分积累的算法知识，对我机试也有重要的作用，如果这些都不懂，那么机试的数据结构题目将无从下手，今年上机第四题普利姆算法题可能就动不了笔，如此简单的一个算法不会，可能就会动摇录取结果。所以一个决定要学习计算机的人，基本的数据结构和算法没有放弃这一说。算法弄完就开始做历年408真题了，这时候做408已经是第三遍了，因为绝大多数或者说全部都已经在四本王道单科书做过，所以这个时候做408是完完全全的背答案，刷熟练度。所以408真题的作用并不是测试用，而是巩固知识。408做完后就可以做803了，实在是太简单了，虽然说803的题目会充分展现北邮特色，计网的选择题会有几道你从来没复习到过的(同时也是你翻遍书也复习不到的)，最骚的是有时还把题目出错了，你将错就错还是没分。所以803考起来就是两个字，“简单”，最后出成绩，分都不高。 2019/4/6 早 续 ​ 政治，讲到这个东西，肖秀荣走起来，前期精讲精练，1000题。中期八套卷，后期4套卷。政治作为考研复习科目的调味剂，每天复习着让人头痛的数学和专业课，看政治还饶有余味。看的顺序就是精讲精练顺序，我是从9月底开始看的，开始时精讲精练一个一个字看，后到后面觉得这样不可能看完的，于是就只看黑体字，然后做1000题。看一章精讲精练，做一章1000题。速度提升了很多，不过1000的正确率惨不忍睹啊，单选题做的还可以，多选题一般都要错一半。马原和毛中特的进度会比较慢，后面几门的进度就快多了。复习完政治第一轮过后，1000题开始二刷。买了几支Mark笔，开始边画边背1000题。虽然说最后没有多大卵用，考试又不会考原题，该不会还是不会。不过政治结果还行。拿了63分，客观题34，主观题29还算不错了。 备考后期​ 这个时候已经将近12月了，数学一轮复习资料，垃圾习题集已经做完了，真题第一遍已经刷完了。而后开始刷模拟题，因为没题目做了，做过一遍的东西没心情二刷。数学基本上还是坚持每天一套卷子，知道考试，从未间断。英语到了12月要开始背作文了，一篇大作文，一篇小作文，用的是王江涛的《高分写作》，买的高分写作字帖假装练字。作文背了不少，强化篇的小作文背了一大半，大作文背了一半左右，还有有一点作用，虽然最后分也不高，两篇作文19分，但是我自己的英语水平心里清楚，该背还是要背。政治的话，就是肖八肖四了，肖八的选择题非常之难，基本上每次都30不到27，28个样子，最低一次拿了24。实在是太惨了。肖八做了两遍，每天一套选择题。后面肖四发货，开始被肖四主观题大题，花了不少时间背题目，但是结果一般，因为我实在是不擅长背诵写作。但是也过得去，毕竟一个我不擅长的东西，考到这个分也令自己满意了。专业课后期基本断档，因为没有资料可以复习了，王道八套卷的选择题刷了一刷，大题的算法题看了看，其他的题目没有动。就开始“等死了”，因为我自己认为应该从数学上与科班的学生拉开差距，我自认为数学学得还行，专业课肯定比不过科班的学生。所以专业课属于战略性放弃。 2018/12/23​ 考试第一天，开始考政治，我起的很早，吃完早饭，书包里背着4套卷，进考场教室之前背了背，老师说；“要发卷子了，都进去吧”，于是我把东西书啊，手机啊，关机放包里。随意从手里摸出一张身份证，和准考证一起给老师看，于是进考场，找位置坐下，坐下的时候，我把身份证往桌上一放，于是戏谑的一幕发生了，我发现我手里拿的不是身份证，然后手往兜里一摸，“还好，身份证在兜里”。哈哈哈哈哈，被自己的SB举动笑到了，我居然不带身份证走进了考场，监考老师也蛮好的，看我拿的北邮的一考通，知道我是北邮的，又马上考试了，所以选择了睁一只眼闭一只眼。(hahaha 自己的确是傻乎乎的，总做一些中二的事情出来)。之后发卷子，写卷子，选择题不会就蒙，大题没有背到的就编，稀里糊涂考完了，内心毫无波澜。 下午考英语 ​ 中午午觉简单睡了下，还有点没有睡醒，迷迷糊糊的，洗了把冷水脸没有多大效果，大脑迷糊的，每次睡午觉之后都是这种感觉。上了考场，试卷还算简单，非常平稳的做完了，只有小作文的称呼当时不知道咋写，就空那儿了没有写，最SB的是，我试卷写完之后，我把这事给忘了，然后假装检查(我做试卷从来没有检查的习惯)，直到老师说交卷子，我随手把卷子一翻，“天啊，我称呼没有写”，随手写了个，写错了，吐了，再改一个，停笔了。突然想起来，政治也是，最后也发现有个题放着没有做，考试结束才想起来，然后涂了一下选择题好像是，我也记不清楚了。 ​ 第一天的考试还算顺利，因为政治不会可以乱编，英语不会可以蒙，我能给自己找一个蒙的理由。之后英语一还上了当天的热搜，我想，“这英语一不是和往年一个难度吗？”。当天还属于正常发挥，英语题目做的很平稳，所以最后还考得不错，拿了75。 2018/12/24​ 这一天是重头戏，上午考数学，我自认为数学学的还可以，计划原来卷子简单考135左右，卷子难，力取120。卷子发下来，立马做，其实有点慌张了，一般情况我都喜欢把试卷上所有题目所有大题大概浏览一下，看是哪些题型，做到心里有数。但是我总想着抓紧时间做，留时间检查。所以25分钟不到把选择填空写完了，因为我认为自己的慢热型的，做小题可能当时没思路，但是把卷子写完再回过头来做自己跳过的小题，立马上想起来了，所以我做小题的策略是，半分钟没思路就跳。跳了几道题。然后做概率题，很简单，做得不顺，做到一半发现自己题目理解错了，涂掉，再做一遍，有一问没有做出来，于是又卡了好久，跳过了。做完之后做线代，读完题目，这题目也太简单了，于是开始算，算到一半，我是不是算错了，检查一下，真的错了，再算一次，上矩阵这个位置写的是什么？我是不是算错了，再算一遍，真的算错了，就这样，一个简单的题，我算个矩阵的逆至少了算了6遍，心态开始崩塌。不算了，跳过。做第二道大题，也太简单了吧，又开始算，和第一题一样，连续出现计算失误，不算了，跳过。这时候跳过两道计算，半道概率。开始转高数，抬头看，这时候只有50分钟，5道高数大题没有做。转到另一个不是那种纯计算的题目，心态平稳了一些，前三道大题顺利的做完了，其中第三道大题，看到这道题我当时就惊了，我同桌曾经拿过这道题问我，是李林模拟卷的题目，我个人是不信李林的当时，因为李林在18年高出大事情来了，我想，“你今年出书就是捞一笔把，还敢搞事情？”，尼玛，最后不得不信，不过不是押题了，因为这卷子出的早。原因我等考研学子也不用想了，数学能不能押中题，是谁抄谁的，这些都不重要了。该看的押题卷还是要看。说到这，还好我同桌给我看了，不然，我当时的情况，在考场了看到这道题还不知道能不能算不出来。然后做第4道大题，其实这道题李林的押题笔记上有，我考前的晚上下下来了，嫌弃笔记字丑，又觉得李林不可能压中，所以没看。这还是我这天晚上想到自己考的数学，想着难受，把李林拿出来看了才知道，当时真的后悔啊！第4道题不会，第一问也不会，第5道题完全不会，看了下，一个斜锥，做三重积分，不知道怎么积，不会，这时候还有大概20分钟，应该是这样，我记不清楚了，所以这时候的情况是，有大概3道小题是随手蒙的(但是我已经忘了有3道题蒙的，被计算折磨的忘了)，我把两道线性代数题接着没算完的地方继续算，结果算出来了，写了上去，第二道也一样，以为算出来了(实际上算错了，不过关系不大，只扣2分)，写了上去。概率有一问没有做，再去想了会，不会，瞎写了一点(最后这道题扣了4分)，然后两道大题，想了想，假装写了写，最后还是不会，只剩5分钟了，于是打算放弃了，计划5分钟检查。于是把相关的公式啥的，比如做极限，假装写个有界性，再假装写个单调性，相关的写一些，积分题目，三重积分公式写一下，假装算一算，这个过程大概花了2到3分钟，都是乱写的(你猜最后怎么样，两道完全不会做的题目，最后竟然拿了11分，这两道题满分也就22分，我瞎写的，拿了11分，我自己都不敢信)，最后交卷了，交卷完才想起来，我前面是不是蒙了几道小题没有做？我整个人心态被搞炸了，都忘了，因为蒙的，答题卡也填满了，没有发现，所以做的很烂。 ​ 考完数学，被这题目恶心到了，中午饭也没吃，去超时买了些东西吃，卡里就10多块钱了，自己也不知道，手机也没带，所以就拿了10多块的东西会宿舍，吃了一会，睡觉。很难受，觉得自己凉了。睡到下午，去考专业课。 ​ 假装睡了一会之后，迷迷糊糊的，洗个冷水脸，心情平复了一些。上考场，这时候我已经知道，我数学考砸了，原因不是题目太难，难的只有两道，就算全部扣掉还有130分，原因是我自己太急了，着急了做小题，想留时间给大题，越急越出错。所以我专业课的卷子发下来，我把卷子大题先大致看了一遍，看是哪些知识点。看完之后心里有数，“这卷子简单”，心里这样想，于是我做的很慢，小题平稳发挥，写完了(后面连蒙几道计网选择题，但是丝毫不慌，我知道803就这样，别人一样复习不到的，大家用一样的复习资料)，然后大题，写试卷了，上来就是两道算法题，都很简单，我先在草稿纸上写一遍，然后腾上去，试卷做的十分漂亮，记得大概最后还剩40分钟，已经有人交卷了，我还有两道大题没做，但是完全不慌，时间足够。最骚的是计网的最后一道大题，服务器地址竟然是192.168.。。。。。。啥玩意，再看一眼题目，远程服务器，???心里想，“题目出错了？应该不会吧，将错就错吧，题目怎么出，我怎么写”，803简直是天坑啊，题目出错了，最后我买单。不过到最后影响不大，专业课拿了128分。还是挺满意的，因为绝大部分人都比自己预估的少十几二十分。 ​ 所以这个时候初试已经完全结束了，但是实际的成绩怎么样，心里是完全没有逼数的，答案也懒得对，因为怕对了答案想放弃，万一过了院线呢？还有调剂的机会(虽然我自认为跨专业调剂很难，跨考分低，凭什么要你？)，万一过了组线，还有一搏的机会，已经努力了这么久，我不想放弃。 初试结束 ​ 这个时候，考完初试休息了一个星期，开始准备机试买了《算法笔记》,外号晴神宝典。刷了刷PAT乙水题，然后在CSDN上找到了历年的机试题目，开始刷，刚开始只会AB题，后面两道题是真的难。要不根本想不出来，要不就是字符串处理的题目，代码量非常大。 AB题型大致以下几类： 1.简单数学问题，进制，质数之类 2.字符串题目，简单模拟一些操作 3.矩阵问题，矩阵乘法，旋转之类 很少考大数，很少考一些其他的数学问题 CD题型大致为 1.数据结构，树，图，并查集都是常考的 2.搜索，DFS 3.贪心 4.字符串处理 模拟操作，非常繁杂 历年真题加上19年会有将近90道题目，抛去太难的题目，题量是很大了。建议学习的时候先学一下OJ基础知识 1.OJ常识 AC WA TLE RE 这些知道是什么意思，以及什么样的情况会导致上述错误 2.OJ的输入输出是什么样子的， 3.重定向输入 在main 函数第一行添加 freopen(“in.txt’, “r”, stdin); 等等，想不起来了。 ​ 跨考的在初试过后的3个月时间，好好准备准备机试拿下3A是有可能的。不过今年网研上机太水了，80多个4A，而我只能3A，比较菜。 ​ 说说笔试，按照往年学长学姐的经验，笔试不重要，但是我还是不敢不看，我作为一个跨考的学生，笔试一门没有学过，100分的选择题，全部乱蒙，期望是25分，折算成30分，也就是8分。所以说笔试，虽然说鸡肋，老师不大看，也不问，但是拿个个位数的分数搁谁身上都有点慌吧，虽然说往年有笔试个位数被录取的。但是还是不应该轻视。看看课件，上网下一些试题，直接抄答案。 2019/2/27复试开始​ 27号政审，29号上午机试，我去得稍有些晚，别人都坐满了上机了，我才去，所以应该去早一些。上去先看黑板，按提示打开电脑，然后把模板写上去，等待机试开始。机试开始，打开第一题，太简单了吧，刷刷刷写完，第二题，这么简单的题拿来考研究生，马上敲完了，第三题，也简单，数组模拟一下，“纳尼，居然错了”，然后开始debug，实在不知道哪里错了，就停了，做第四题，看完题目，就知道，这题就是写普利姆算法，然后回忆一下普利姆算法该怎么写，写了一会，调了一下bug，调完了，交上去，通过。然后看第三题，当时sb了，数组模拟不出来，应该换个思路的，STL模板vector就挺好用的，当时没有想到，所以这道题一直没有通过。 ​ 29号下午笔试，当然笔试是非常难的，很少人拿到20分。我也只拿了17分，因为这东西不好复习，在下面做的练习绝大部分都没用，但是比不做好。出的题目有些课件里面也没有见过。所以做题就是连猜带蒙。数据库，软件工程，人工智能比较简单，其他三门都不好啃，通原和编译原理直接放弃，所以跨考生一门都没学过的一般没得选择。 ​ 30号面试 ​ 面试经历惨不忍睹，停笔！！！ 写在最后​ 最后，上岸的自己满心欢喜。已经不想学习了，放松一下，最近几天在看B站的法考，有点意思，刑法主讲人是罗翔，上课非常有趣。追了几天课。有次不经意点到一个罗翔当客服接电话的片段，一个女生打来了电话，电话问“我是0基础的，想考法考，现在是从基础班开始看还是怎么学，罗老师能指点一下吗”，“从强化班开始看就可以”，“我是0基础的，会不会看不懂？”，“有时候小白可能更加容易通过司法考试，因为他有一颗谦卑的心”。短短1分钟左右的视频，我回想起自己的考研历程，刚开始跨专业考研，觉得专业课基本没学过，所以学的很细心，我英语很菜，所以我学的很认真，我的数学是我最有信心的，我自认为我数学从小就不差，然后考的相当爆炸。所以说在有些时候，优势反而是劣势，劣势反而是优势，对未来保持一个谦卑的心态，放低自己的姿态，从容的面对即将到来的东西，不要急，不要赶，不要想着拿高分，不要想着证明自己，保持一颗谦卑的心态，平稳前行。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北邮机试模板]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8C%97%E9%82%AE%E6%9C%BA%E8%AF%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[​ 这是我在准备北邮上机考试时准备的模板，其中不少是来自北邮的历年机试真题，还有一部分来自PAT书。但是北邮网研今年不能携带纸质资料了，但还好今年题目简单。 ​ 北邮机试有它自己的特点，一般前两道题比较简单，一般就是简单的数学问题，进制问题，简单的字符串问题， 质数问题，打印图案等等。前两道题是比较容易轻松拿下的。后两道题有时候就会比较难的，树，图，搜索，并查集，贪心，DP，还有很恶心的字符串处理题目。其中树和图的模板性较强。但是我看过PAT书和王道书的模板都是严书数据结构类似。建议在这里使用全部使用数组存储，会容易很多。字符串的题目可以看看sscanf, 可以匹配正则表达式，用作提取字符串可谓一大神器，比stl模板库string还好用！！！ 上机模板： 模板一 打印素数表123456789101112131415161718192021222324/* PAT P161 */const int MAXNUM = 105000;const int maxn = 10010;bool prime[MAXNUM] = &#123;false&#125;;int p[maxn];int FindPrime()&#123; int index = 0; for(int i = 2; i &lt; MAXNUM; i++) &#123; //如果未标记则得到一个素数 if( !prime[i] ) p[index++] = i; //标记目前得到的素数的i倍为非素数 for( int j = 0; j &lt; index &amp;&amp; p[j] * i &lt; MAXNUM; j++ ) &#123; prime[i * p[j]] = true; if( i % p[j] == 0 ) break; &#125; &#125; return index;&#125; 1234567891011121314151617181920212223const int MAXNUM = 105000;const int maxn = 10010;bool prime[MAXNUM] = &#123;false&#125;;int p[maxn];bool isprime( int x )&#123; for( int i = 2; i &lt;= sqrt(x*1.0); i++ ) if( x % i == 0 ) return false; return true;&#125;int cursor = 0;void FindPrime()&#123; for( int i = 2; i &lt; MAXNUM; i++ ) if( isprime(i) ) &#123; prime[i] = true; p[cursor++] = i; &#125; &#125; 备注：写完这个函数一定要记得把FindPrime()写到主函数里面去！！！ 第 100个素数 = 541 第 1000个素数 = 7919 第10000个素数 = 104729 第20000个素数 = 224737 第30000个素数 = 350377 第40000个素数 = 479909 第50000个素数 = 611953 第60000个素数 = 746773 第70000个素数 = 882377 第80000个素数 = 1020379 模板二 大数一、基本函数： 1.valueOf(parament); 将参数转换为制定的类型 比如 int a = 3; BigInteger b = BigInteger.valueOf(a); 则b=3; String s= “12345”; BigInteger c = BigInteger.valueOf(s); 则c = 12345； 2.add(); 大整数相加 BigInteger a=new BigInteger(“23”); BigInteger b=new BigInteger(“34”); a.add(b) 3.subtract(); 相减 4.multiply(); 相乘 5.divide(); 相除取整 6.remainder(); 取余 7.pow(); a.pow(b)=a^b 8.gcd(); 最大公约数 9.abs(); 绝对值 10.negate(); 取反数 11.mod(); a.mod(b)=a%b=a.remainder(b); 12.max(); min(); 13.public int comareTo(); 14.boolean equals(); 是否相等 15.shiftLeft():左移，this &lt;&lt; n ，this*2^n; shiftRight():右移，this &gt;&gt; n，this/2^n; 16.bitLength：返回该数的最小二进制补码表示的位的个数，即 不包括 符号位 (ceil(log2(this &lt;0 ? -this : this + 1)))。对正数来说，这等价于普通二进制表示的位的个数。 17.bitCount：返回该数的二进制补码表示中不包扩符号位在内的位的个数。该方法在 BigIntegers 之上实现位向量风格的集合时很有用。 18.isProbablePrime：如果该 BigInteger 可能是素数，则返回 true ；如果它很明确是一个合数，则返回 false 。 参数 certainty 是对调用者愿意忍受的不确定性的度量：如果该数是素数的概率超过了 1 - 1/2**certainty方法，则该方法返回 true 。执行时间正比于参数确定性的值。 19.nextProbablePrime()：获取下一个可能的素数是多少 20.BigInteger构造函数： 一般用到以下两种： BigInteger(String val); 将指定字符串转换为十进制表示形式； BigInteger(String val,int radix); 将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger 二、注意 1.其构造方法有很多，常用的邮： BigInteger(String val) 将 BigInteger 的十进制字符串表示形式转换为 BigInteger。 BigInteger(String val, int radix)将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger。 2.进行数学运算时不能直接使用数学运算符进行运算，必须使用其内部方法。而且其操作数也必须为BigInteger型。 3.当要把计算结果输出时应该使用.toString方法将其转换为10进制的字符串：System.out.print(two.toString()); 三、进制转换 我最喜欢的功能，因为直接实现了算法，就不用我写了。可以使用以下函数，转换成字符串后如果存在abc等字符默认的是小写，如果转换成大写可以加上.toUpperCase()； 123private static String change(String num, int from, int to) &#123; return new BigInteger(num, from).toString(to);&#125; 四、案例 123456789101112131415161718192021222324252627282930313233import java.math.BigInteger;import java.util.Scanner;public class numNodeofAVL &#123; static int maxn = 100000; static BigInteger H[] = new BigInteger[maxn]; /** * @param args */ public static void main(String[] args) &#123; //int maxn = 100; //BigInteger H[] = new BigInteger[maxn]; H[1] = BigInteger.valueOf(1); H[2] = BigInteger.valueOf(2); int i = 3; while( i &lt; maxn ) &#123; H[i] = H[i-1].add( H[i-2]).add(H[1]); i++; &#125; Scanner cin = new Scanner( System.in ); System.out.print("请输入数据组数："); int T = cin.nextInt(); int n; while( T-- &gt; 0 )&#123; System.out.print("请输入一个整数："); n = cin.nextInt(); System.out.println( H[n] ); &#125; cin.close(); &#125;&#125; 模板三 表达式求值1/*PAT书 P247 简单计算器 */ 模板四 字符串一、字符串向整数映射( PAT实战 P352) 1234567891011121314map&lt;string, int&gt; stringToInt;map&lt;int, string&gt; intToString;int numList = 0;int change( string str )&#123; if( stringToInt.find(str) != stringToInt.end() ) return stringToInt[str]; else &#123; stringToInt[str] = numList; intToString[numList] = str; return numList++; &#125;&#125; 二、字符串输入 12345678/*输入T组一个带空格的字符串*/string str;int T;cin &gt;&gt; T; //不丢弃换行符getchar() //接受输入整数T后的空格while( T-- ) getline( cin, str ); //遇到换行符停止 并且丢弃换行符 1234string str;char c;while((c=cin.get())!='\n') str+=c; 三、去除字符串的空格 123456pos = find(" ");while( !(pos == string::npos || pos == -1) )&#123; str.erase( pos, 1 ); pos = str.find(" ") ;&#125; 四、十六进制转十进制 123456789101112131415int hexToDec( string str )&#123; int len = str.size(); int sum = 0; for( int i = 0; i &lt; len; i++ ) &#123; int num; if( isdigit(str[i]) ) num = str[i] - '0'; else num = str[i] -'a' + 10; sum = sum * 16 + num; &#125; return sum;&#125; 五、STL String类型(PAT P202) 1234567891011str1 += str2 //直接拼接字符串&lt; &gt; == //按字典序比较字符串size()/length() //z字符串长度insert( pos, str) //在pos处插入字符串strerase(it)erase(first, last) // 迭代器类型 左闭右开erase(pos,len) //int类型 指定类型及其长度substr(pos, len) //提取子串find(str) //返回str第一次出现的位置find(pos,str) //返回str在pos位置之后出现的位置replace(pos,len,str) //将起始位置为pos，长度为len的那部分替换为字符串str 六、例题 12345678910111213141516171819202122232425262728293031323334353637383940/**给出一句英文句子(只由大小写字母和空格组成，不含标点符号，也不会出现连续的空格),请将其中的所有单词顺序翻转**//// 没有多余空格 可以使用 cin 输入 自动跳过空格 并且将单词入栈。全部入栈后出栈即可#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; stack&lt;string&gt; s; string str; bool firstcase; while( cin &gt;&gt; str ) &#123; //实现多组数据的输入 ///Initstack while( !s.empty() ) s.pop(); firstcase = true; ///Input while(1) &#123; s.push(str); /*因为 在cin 最后一个单词后 str被压入栈中 但是输入缓冲队列 还保存着 回车符 cin并不会丢弃回车符*/ if( getchar() == '\n') break; cin &gt;&gt; str; &#125; ///output while( !s.empty() ) &#123; if( firstcase ) firstcase = false; else cout &lt;&lt; " "; str = s.top(); cout &lt;&lt; str; s.pop(); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 模板五 树模板一、树的存储一、父亲孩子表示法12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#define maxsize 1010using namespace std;// 父亲孩子表示法( 同时记录双亲和孩子位置 )struct Node&#123; int data; /// 节点值 为 父节点 所在数组 下标 vector&lt;int&gt; sonList; ///根节点 data 值为 -1； bool turnOn; ///此二叉树节点是否有效 Node() &#123; initNode(); &#125; void initNode() &#123; turnOn = false; sonList.clear(); &#125;&#125;; 二、建树1234567891011121314151617181920212223242526Node Tree[maxsize]; ///用一维数组来存储一颗二叉树int createNode( int data, int index ) ///在数组下标 index 处创造一个节点&#123; Tree[index].data = data; Tree[index].turnOn = true; return index;&#125;void createTree( int N )&#123; /// Tree[]初始化 for( int i = 0; i &lt; maxsize; i++ ) Tree[i].initNode(); cursor = 0; int x,y; N--; /// 此树有N个节点,N-1条边 while( N-- ) &#123; cin &gt;&gt; x &gt;&gt; y; /// x 是 y 的父节点 if( Tree[x].turnOn == false ) /// X 节点没有创建 即 X 是根节点 createNode( -1, x ); Tree[x].sonList.push_back( y ); /// 创造节点后 记录孩子节点 if( Tree[y].turnOn == false ) createNode( x, y ); &#125;&#125; 三、删除树 1234567891011void freeNode( int index )&#123; Tree[index].initNode();&#125;void freeTree( int index ) ///采用递归的方式释放一棵树&#123; Node &amp;nowp = Tree[index]; for( int i = 0; i &lt; nowp.sonList.size(); i++ ) freeTree( nowp.sonList[i] );&#125; 四、二叉树的存储和求深度与层次遍历12345678910111213141516171819typedef struct BiNode&#123; int data; int lc; ///左孩子的数组下标 int rc; ///右孩子的数组下标 int deep; bool turnOn; ///此二叉树节点是否有效 BiNode() &#123; initNode(); &#125; void initNode() &#123; turnOn = false; deep = -1; lc = rc = -1; &#125;&#125;; 五、二叉树的建立与删除12345678910111213141516171819202122232425262728293031323334353637383940414243BiNode Tree[maxsize]; ///用一维数组来存储一颗二叉树int cursor;int t, n, m;int createNode( int index ) ///在数组下标 x 处创造一个节点&#123; Tree[index].data = index; Tree[index].turnOn = true; Tree[index].lc = Tree[index].rc = -1; return index;&#125;void creatTree()&#123; int a,b; /// a 的 父节点是 b; createNode(0); ///创建根节点 cin &gt;&gt; n &gt;&gt; m; /// n 行 m 个 节点 while( n-- ) &#123; cin &gt;&gt; a &gt;&gt; b; a--; b--; createNode( a ); ///创建 a 节点 if( Tree[b].lc == -1 ) /// 无座孩子 先写入左孩子 Tree[b].lc = a; else Tree[b].rc = a; &#125;&#125;void freeNode( int index )&#123; Tree[index].initNode();&#125;void freeTree( int index ) ///采用递归的方式释放一棵树( 后序方式 ）&#123; if( index == -1 ) /// 递归出口 return; freeTree( Tree[index].lc ); ///递归删除左子树 freeTree( Tree[index].rc ); ///递归删除右子树 Tree[index].initNode(); ///删除根节点&#125; 六、二叉树计算深度与层次遍历123456789101112131415161718192021222324252627282930313233343536373839void calDeep( int root, int nowDeep ) ///先序递归方式求出各节点所在的层次&#123; if( root == -1 ) return; Tree[root].deep = nowDeep; calDeep( Tree[root].lc, nowDeep+1 ); calDeep( Tree[root].rc, nowDeep+1 );&#125;void levelOrder( int root ) ///从第 nowDeep 层开始 非递归的层次遍历root 为根节点的二叉树&#123; bool firstCase = true; int nowDeep = 1; queue&lt;BiNode&gt; q; while( !q.empty() ) ///队列初始化 q.pop(); q.push( Tree[root] ); ///根节点入队 while( !q.empty() ) &#123; BiNode &amp;nowNode = q.front(); q.pop(); if( nowNode.deep != nowDeep ) ///到了下一层 &#123; cout &lt;&lt; endl; nowDeep++; firstCase = true; &#125; if( firstCase ) firstCase = false; else cout &lt;&lt; " "; ///从if到这里 按层打印 cout &lt;&lt; nowNode.data+1; ///访问节点 if( nowNode.lc != -1 ) q.push( Tree[nowNode.lc] ); if( nowNode.rc != -1 ) q.push( Tree[nowNode.rc] ); &#125;&#125; 七、树的双亲表示法( 并查集模板)可解决问题：求两个节点的最近公共祖先( 2014-软件-C) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;stack&gt;#define MAXSIZE 500using namespace std;struct Set&#123; ///并查集模板 int root[MAXSIZE]; int setSize; int initSet( int setSize ) &#123; this -&gt; setSize = setSize; for(int i = 0; i &lt; setSize; i++ ) root[i] = -1; &#125; int FindRoot( int v, stack&lt;int&gt; &amp;s ) &#123; s.push(v); while( root[v] != -1 ) &#123; v = root[v]; s.push(v); &#125; return v; &#125;&#125;;int main()&#123; int T, N, M; scanf( "%d", &amp;T ); Set set; stack&lt;int&gt; fa1, fa2; int u, v; int i, j; for( i = 0; i &lt; T; i++ ) &#123; scanf("%d", &amp;N ); set.initSet( N ); for( j = 0; j &lt; N-1; j++ ) &#123; scanf( "%d%d", &amp;u, &amp;v ); u--; v--; set.root[v] = u; &#125; scanf("%d", &amp;M); for( j = 0; j &lt; M; j++ ) &#123; while( !fa1.empty() ) fa1.pop(); while( !fa2.empty() ) fa2.pop(); scanf( "%d%d", &amp;u, &amp;v ); u--; v--; //边找根边将所有祖先入栈 set.FindRoot( u, fa1 ); set.FindRoot( v, fa2 ); int root1 = 1, root2 = 1, LCA; while( !fa1.empty() &amp;&amp; !fa2.empty() ) &#123; root1 = fa1.top(); root2 = fa2.top(); fa1.pop(); fa2.pop(); if( root1 == root2 ) LCA = root1; else break; &#125; printf("%d\n", LCA+1 ); &#125; &#125;&#125; 八、例题 1、13-网研-D-文件系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxsize = 101;struct Node&#123; string name; int data; vector&lt;int&gt; sub; Node() &#123; initnode(); &#125; void initnode() &#123; data = -1; sub.clear(); &#125;&#125;;Node Tree[maxsize];int cursor = 0;void createnode(string str1, string str2, int type)&#123; int i; Tree[cursor].name = str1; Tree[cursor].data = type; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str2 ; i++ ); Tree[i].sub.push_back(cursor++);&#125;int main()&#123; int T, N; cin &gt;&gt; T; string command, str1, str2; while( T-- ) &#123; for( int i = 0; i &lt; maxsize; i++ ) Tree[i].initnode(); cursor = 0; Tree[0].data = 1; Tree[0].name = "root"; cursor++; int i, j; cin &gt;&gt; N; while( N-- ) &#123; cin &gt;&gt; command; if( command == "CREATEFILE" ) &#123; cin &gt;&gt; str1 &gt;&gt; str2; createnode( str1, str2, 0 ); &#125; else if( command == "CREATEDIR" ) &#123; cin &gt;&gt; str1 &gt;&gt; str2; createnode( str1, str2, 1 ); &#125; else if( command == "LISTFILE" ) &#123; cin &gt;&gt; str1; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str1; i++ ); for( j = 0; j &lt; Tree[i].sub.size(); j++ ) if( !Tree[Tree[i].sub[j]].data ) cout &lt;&lt; Tree[Tree[i].sub[j]].name &lt;&lt; endl; &#125; else if( command == "LISTDIR" ) &#123; cin &gt;&gt; str1; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str1; i++ ); for( j = 0; j &lt; Tree[i].sub.size(); j++ ) if( Tree[Tree[i].sub[j]].data ) cout &lt;&lt; Tree[Tree[i].sub[j]].name &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 二、树的操作1、数的最大深度及其个数( 普通树的孩子表示法 )123456789101112131415161718int maxdep = 0;int maxdep_cnt = 0;void DFS( int root, int dep )&#123; if( !Tree[root].child.size() ) &#123; if( dep &gt; maxdep ) &#123; maxdep = dep; maxdep_cnt = 1; &#125; else if( dep == maxdep ) maxdep_cnt++; return; &#125; for( int i = 0; i &lt; Tree[root].child.size(); i++ ) DFS( Tree[root].child[i], dep+1 );&#125; 2、先序中序求后序1234567891011121314151617bool firstCase = true;void toPost( int prel, int prer, int inl, int inr )&#123; int i; for( i = inl; i &lt;= inr &amp;&amp; in[i] != pre[prel]; i++ ); int llen = i - inl; int rlen = inr - i; if( llen ) toPost( prel+1, prel+llen, inl, i-1 ); if( rlen ) toPost( prer-rlen+1, prer, i+1, inr ); if( firstCase ) firstCase = false; else cout &lt;&lt; " "; cout &lt;&lt; pre[prel];&#125; 3、中序后序求先序12345678910111213void preorder( int poststart, int postend, int instart, int inend )&#123; cout &lt;&lt; post[postend] &lt;&lt; " "; ///根据后序序列打印 根节点 int i; for( i = instart; i &lt;= inend &amp;&amp; post[postend] != in[i]; i++ ); int llen = i - instart; ///左子树长度 int rlen = inend - i; ///右子树长度 if( llen ) preorder( poststart, poststart + llen - 1, instart, i-1 ); if( rlen ) preorder( postend - rlen, postend-1, i+1, inend ); return;&#125; 4、后序中序建树1234567891011121314int createTree( int poststart, int postend, int instart, int inend )&#123; int root = post[postend]; createNode( root ); ///根据后序序列创建 根节点 int i; for( i = instart; i &lt;= inend &amp;&amp; post[postend] != in[i]; i++ ); int llen = i - instart; ///左子树长度 int rlen = inend - i; ///右子树长度 if( llen ) BiTree[root].lc = createTree( poststart, poststart + llen - 1, instart, i-1 ); if( rlen ) BiTree[root].rc = createTree( postend - rlen, postend-1, i+1, inend ); return root; ///返回后序根节点&#125; 三、二叉排序树1、给定数字 排成完全二叉排序树12345678910111213const int maxn = 1000;int num[maxn], CBT[maxn];int index = 0;int N;void inorder( int root )&#123; if( root &gt; N ) return; inorder( 2*root ); CBT[root] = num[index++]; inorder( 2*root+1);&#125; 2、给定树型 排成二叉排序树123456789101112BiNode BST[maxn];int num[maxn];int index = 0;void inorder( int root )&#123; if( root == -1 ) return; inorder( BST[root].lc ); BST[root].data = num[index++]; inorder( BST[root].rc );&#125; 3、按给定序列一次插入构建二叉排序树12345678910111213141516171819202122232425int index = 0;void Insert( int data )&#123; if( index == 0 ) //插入第一个节点 &#123; Tree[index++].data = data; return; &#125; int root = 0; int parent = -1; Tree[index].data = data; //插入节点 while( root != -1 ) //找s父节点 &#123; parent = root; if( data &lt; Tree[root].data ) root = Tree[root].lc; else if( data &gt; Tree[root].data ) root = Tree[root].rc; &#125; if( data &lt; Tree[parent].data ) Tree[parent].lc = index; else if( data &gt; Tree[parent].data ) Tree[parent].rc = index; index++;&#125; 四、哈夫曼树1234567891011121314151617181920/*哈夫曼树带权路径和为所有节点和( 包括非叶节点 )*/#include&lt;queue&gt;priority_queue&lt;int , vector&lt;int&gt;, greater&lt;int&gt; &gt; Q; //建立一个小顶堆int calWPL()&#123; int ans=0; while(Q.size()&gt;1) //Q 的初始值为各个节点的值 &#123; int a=Q.top(); Q.pop(); int b=Q.top(); Q.pop(); ans+=a+b; Q.push(a+b); &#125; return ans;&#125; 模板六 图模板一、图的存储1、邻接矩阵 1234567891011int G[maxn][maxn] = &#123;0&#125;;int dist[maxn][maxn] = &#123;0&#125;;bool visit[maxn] = &#123;false&#125;;//建图while( M-- )&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u][v] += w; G[v][u] += w;&#125; 2、领接表 123456789101112///定义一个领接表vector&lt;int&gt; G[MAXSIZE];///设置访问标记数组bool visit[MAXSIZE] = &#123;0&#125;;//输入边建图while( M-- )&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back( v ); G[v].push_back( u ); Union( u, v );&#125; 二、弗洛伊德算法1234567891011121314151617181920212223const int maxv = 50;int dist[maxv][maxv];int vertex[maxv][maxv];///弗洛伊德算法void Floyd( int n )&#123; int i, j, k; ///Initiate for( i = 0; i &lt; n; i++ ) for( j = 0; j &lt; n; j++ ) if( vertex[i][j] ) dist[i][j] = vertex[i][j]; else dist[i][j] = n; for(k = 0; k &lt; n; k++ ) for( i = 0; i &lt; n; i++ ) for( j = 0; j &lt; n; j++ ) if( dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j];&#125; 三、Dijkstra算法( 堆优化 )12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxn = 1010;const int INF = 0x3f3f3f3f; //无穷大int G[maxn][maxn] = &#123;0&#125;;int via[maxn] = &#123;0&#125;;int N, M, K;///Dijkstra最短路径算法int dist[maxn][maxn] = &#123;0&#125;;bool visit[maxn] = &#123;false&#125;;///优先队列int cur;struct cmp&#123; bool operator () (int a,int b)&#123; return dist[cur][a]&gt;dist[cur][b]; &#125;&#125;;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; pq;void Dijkstra( int u )&#123; int mincost; cur = u; memset( visit, false, N+1 ); dist[u][u] = 0; while( !pq.empty() ) pq.pop(); pq.push( u ); while( !pq.empty() ) &#123; mincost = pq.top(); pq.pop(); if( visit[mincost] ) continue; visit[mincost] = true; for( int i = 0; i &lt;= N; i++ ) if( G[mincost][i] &amp;&amp; !visit[i] &amp;&amp; dist[u][i] &gt;= dist[u][mincost] + G[mincost][i] ) &#123; dist[u][i] = dist[u][mincost] + G[mincost][i]; pq.push( i ); &#125; &#125;&#125; 四、经过若干中间节点的最短路径123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int T; cin &gt;&gt; T; int N, M, K; int u, v, w; while( T-- ) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; memset( G, 0, sizeof(G) ); memset( dist, INF, sizeof(dist) ) //邻接矩阵建图 while( M-- ) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u][v] += w; G[v][u] += w; &#125; //计算各个中间节点到其他节点的单源最短路径 for( int i = 0; i &lt; K; i++ ) &#123; cin &gt;&gt; via[i]; Dijkstra( via[i] ); &#125; int shortpath = INF; Dijkstra(1); //核心代码 sort( via, via+K ); do &#123; int temppath = dist[1][via[0]]; for( int i = 0; i &lt; K-1; i++ ) &#123; int u = via[i]; int v = via[i+1]; temppath += dist[u][v]; &#125; if( temppath &lt; shortpath ) shortpath = temppath; &#125;while( next_permutation( via, via+K )); cout &lt;&lt; shortpath &lt;&lt; endl; &#125; return 0;&#125; 五、多条最短路径最优算法（ PAT实战 P369 ）方法一、修改Dijkstra( PAT P388) 方法二、Dijkstra 保存路径 DFS( PAT P389) 六、无环图找根使树高最大1、从某一定点 u 出发DFS找最深节点集合 123456789101112131415161718int maxH = 0;set&lt;int&gt; temp, A, B; //使用set类型是因为方便做并集运算bool visit[MAXSIZE] = &#123;0&#125;;void DFS( int u, int Height )&#123; visit[u] = true; if( Height &gt; maxH ) &#123; temp.clear(); temp.insert( u ); maxH = Height; &#125; else if( Height == maxH ) temp.insert( u ); for( int i = 0; i &lt; G[u].size(); i++ ) if( !visit[G[u][i]] ) DFS( G[u][i], Height+1 );&#125; 2、从上最深顶点任选一顶点进行DFS找最深节点集合 3、最大深度跟集合为两集合的并集 主函数代码如下 1234567891011121314151617181920212223int main()&#123; int N, M; cin &gt;&gt; N; M = N-1; int u, v; while( M-- ) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back( v ); G[v].push_back( u ); &#125; DFS( 1, 1 ); A = temp; memset( visit, false, sizeof(visit) ); DFS( *A.begin(), 1 ); B = temp; for( set&lt;int&gt;::iterator it = B.begin(); it != B.end(); it++ ) A.insert( *it ); for( set&lt;int&gt;::iterator it = A.begin(); it != A.end(); it++ ) cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 七、无环图找根中序遍历 12345678910111213141516171819202122232425bool visit[maxsize] = &#123;false&#125;;void inorder( int root )&#123; visit[root] = true; int i; // 找到第一个未被标记的孩子 即为左子树 遍历玩此左子树 就推出循环 for( i = 0; i &lt; vertex[root].size(); i++ ) &#123; int lc = vertex[root][i]; if( !visit[lc] ) &#123; inorder( lc ); break; &#125; &#125; temp.push_back( data[root] ); //访问根节点 int sonsize = vertex[root].size(); //上述 i 指向第一个左孩子 接下来依次遍历每个右孩子 for( i = i+1; i &lt; sonsize; i++ ) &#123; int rc = vertex[root][i]; if( !visit[rc] ) inorder( rc ); &#125;&#125; 八、DFS同时遍历点集和边集( PAT实战 P350 )1234567891011121314151617void DFS( int now, int &amp;head, int &amp;numMember, int &amp;totalValue )&#123; visit[now] = true; numMember++; if( weight[now] &gt; weight[head] ) head = now; for( int i = 0; i &lt; numPerson; i++ ) &#123; if( G[now][i] ) &#123; totalValue += G[now][i]; G[now][i] = G[i][now] = 0; //删除从 now 到 i 的边 if( !visit[i] ) DFS( i, head, numMember, totalValue ); &#125; &#125;&#125; 九、边权最小 点权最大( PAT实战360 )模板七 搜索一、DFS求连通块例题一、2014-计算机一- C -图像识别 我们将给定一幅N x M的图像，其中每个1 x 1的点都用一个[0,255]的值来表示他的RGB颜色。如果两个相邻的像素点颜色差不超过D，我们就认为这两个像素点属于同一个区域。对于一个像素点(x,y) ，以下这8个点（如果存在）是与它相邻的：（x-1, y-1），（x-1,y），（x-1,y+1），（x,y-1），（x,y+1），（x+1,y-1），（x+1,y），（x+1,y+1）。即 你的任务是写一个程序，分辨出给定图像中一共被分为多少个区域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 101;int data[maxn][maxn] = &#123;0&#125;;bool visit[maxn][maxn] = &#123;0&#125;;//8个方向的坐标遍历技巧int adjx[8] = &#123; -1, -1, -1, 0, 0, 1, 1, 1 &#125;;int adjy[8] = &#123; -1, 0, 1, -1, 1, -1, 0, 1 &#125;;int N, M, D;//判断是否能够到达下一个点 即图中两点之间是否相邻bool isdomain( int x1, int y1, int x2, int y2 )&#123; if( x2 &gt;= N || y2 &gt;= M || x2 &lt; 0 || y2 &lt; 0 || visit[x2][y2] ) return false; if( abs( data[x1][y1] - data[x2][y2] ) &gt; D ) return false; else return true;&#125;//深度优先遍历void DFS( int x, int y )&#123; visit[x][y] = true; for( int i = 0; i &lt; 8; i++ ) &#123; int newx = x + adjx[i]; int newy = y + adjy[i]; if( isdomain( x, y, newx, newy ) ) DFS( newx, newy ); &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while( T-- ) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for( int i = 0; i &lt; N; i++ ) for( int j = 0; j &lt; M; j++ ) &#123; cin &gt;&gt; data[i][j]; visit[i][j] = false; &#125; int domain = 0; for( int i = 0; i &lt; N; i++ ) for( int j = 0; j &lt; M; j++ ) if( !visit[i][j] ) &#123; DFS( i, j ); domain++; &#125; cout &lt;&lt; domain &lt;&lt; endl; &#125; return 0;&#125; 二、并查集(PAT P334)1234567891011121314151617181920212223242526272829303132333435const int MAXSIZE = 1010;///并查集模板int father[MAXSIZE];int initSet( int setSize )&#123; for(int i = 0; i &lt; setSize; i++ ) &#123; father[i] = -1; visit[i] = 0; &#125;&#125;int FindRoot( int v )&#123; int u = v; while( father[v] != -1 ) v = father[v]; //路径压缩 while( father[u] != -1 ) &#123; int z = u; u = father[u]; father[z] = v; &#125; return v;&#125;void Union( int a, int b )&#123; int faA = FindRoot( a ); int faB = FindRoot( b ); if( faA != faB ) father[faB] = faA;&#125; 一、计算集合个数 1234567891011int isRoot[MAXSIZE] = &#123;0&#125;;int calBlock( int n )&#123; int block = 0; for( int i = 1; i &lt;= n; i++ ) isRoot[FindRoot(i)] = true; for( int i = 1; i &lt;= n; i++ ) if( isRoot[i] ) block++; return block;&#125; 二、例题（PAT实战P330） 有N个人，每个人喜欢若干项活动，如果两个人有任意一个喜欢的活动相同，那这两人同属一个社交网络。求N个人总共形成了多少了社交网络 1、判断两个人是否是同一个社交网络 12345678910111213int hobby[MAXSIZE] = &#123;0&#125;; //hobby[act]表示存储喜欢活动act的人的编号for( int i = 1; i &lt;= N; i++ ) //hobby 即为father数组&#123; //初始为0； 第一个喜欢该活动act的人为编号 scanf("%d:", &amp;amount); //后来的把自己和搞活动的并入 while( amount-- ) &#123; scanf( "%d", &amp;act ); if( !hobby[act] ) hobby[act] = i; else Union( hobby[act], i ); &#125;&#125; 模板八 矩阵问题一、矩阵乘法 1234567891011void mulmatrix()&#123; for( int i = 0; i &lt; n; i++ ) for( int j = 0; j &lt; n; j++ ) &#123; int sum = 0; for( int k = 0; k &lt; n; k++ ) sum += A[i][k] * B[k][j]; temp[i][j] = sum; &#125;&#125; 二、矩阵旋转 1、n x n 矩阵原地旋转 12345678910111213void rotate &#123; for(int i=0; i&lt;n/2; i++)&#123; for(int j=i; j&lt;n-1-i; j++)&#123; int temp = matrix[i][j]; matrix[i][j]=matrix[n-1-j][i]; matrix[n-1-j][i]=matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j]=matrix[j][n-1-i]; matrix[j][n-1-i]=temp; &#125; &#125; &#125; &#125; 2、m x n 矩阵借助辅助矩阵旋转 1234567891011void rotate()&#123; int i, j; for( i = 0; i &lt; row; i++ ) for( j = 0; j &lt; col; j++ ) temp[j][row-i-1] = martrix[i][j]; swap( row, col ); for( i = 0; i &lt; row; i++ ) for( j = 0; j &lt; col; j++ ) martrix[i][j] = temp[i][j];&#125; 三、矩阵的Zigzag排列 1234567891011121314151617181920212223/*有四个方向。右、左下、下、右上。左下和右上可以继续，其他的方向需要改变成下一个。*/int dir[4][2] = &#123;&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;-1,1&#125;&#125;; //四个方向int m,n;vector&lt;int&gt; res;vector&lt;vector&lt;bool&gt; &gt; vis; //访问标记vector&lt;vector&lt;int&gt; &gt; matrixvoid dfs( int x,int y,int d )&#123; int cur_x,cur_y; cur_x=x+dir[d][0],cur_y=y+dir[d][1]; if(cur_x&gt;=0&amp;&amp;cur_x&lt;m&amp;&amp;cur_y&gt;=0&amp;&amp;cur_y&lt;n&amp;&amp;!vis[cur_x][cur_y])&#123; res.push_back(matrix[cur_x][cur_y]); vis[cur_x][cur_y] = true; if(d&amp;1) // d为斜方向 dfs(matrix,cur_x,cur_y,d); dfs( cur_x,cur_y,(d+1)%4); dfs( cur_x,cur_y,(d+2)%4); dfs( cur_x,cur_y,(d+3)%4); //其他方向都不行，只能顺着一个方向 dfs( cur_x,cur_y,d); &#125;&#125; 四、螺旋矩阵 同zigzag排列相识，定义四个方向 做访问标记数组判断 五、接雨水 123输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6记录每个位置往左边能到的最大值和往右边能到的最大值（里面选一个小的减去当前高度）就是这个位置能接的水，然后把所有位置能接的水加起来即为结果。 六、排序矩阵中的从小到大第k个数 每一行递增，每一列也递增。 把所有的元素排序，找第k个，这样的复杂度是O（n*logn） 而题目的挑战是O(k*logn)。 我们使用最小堆（优先队列）来实现，每次把元素的右边和下边的元素入队（比当前元素大一点点）。其实入队的操作就是在调整最小堆。【最小堆的实现使用数组vector】 模板九 DP一、最长连续子序列求数组 A[0], A[1] …A[n-1] 的最大连续子序列和。 123456789101112/* dp[0] = A[0];对于下标1...n的元素，以其为结尾的序列最大和为 前 i-1 个元素的最大和在加上自身， 自身的比较即如果 前i-1 个元素和大于0 则此元素附在前 i-1 个序列之后， 否则 自己单开一个序列。*/dp[0] = A[0];for( int i =1; i &lt; n-1; i++ )&#123; if( dp[i-1] &gt; 0 ) dp[i] = dp[i-1] + A[i]; else dp[i] = A[i];&#125; 二、最长连续不下降子序列( LIS )求数组 A[1], A[2] …A[n] 的非递减子序列的最大长度( 可以不连续 )。 123456789101112/*先让每个元素自成一个子序列 长度为1i 从 1 到 n 依次计算 以A[i]结尾的LIS计算的方法是 枚举从 1 到 i的元素 A[j] 判断A[i]接在A[j]后面能够更大 更新A[i] */int ans = -1;for( int i = 1; i &lt;= n; i++ )&#123; dp[i] = 1; for( int j = 1; j &lt; i; j++ ) if( A[i] &gt;= A[j] &amp;&amp; dp[j]+1 &gt; dp[i] ) dp[i] = dp[j]+1; ans = max( dp[i], ans );&#125; 三、最长公共子序列四、最大回文串五、背包一、Leetcode—221.Maximal Square 12345678910111213141516171819202122232425262728/*以矩阵中每一个点作为正方形右下角点来处理，当该点为1时，以该点为右下角点的最大边长最多比以它的左方、上方和左上方为右下角的正方形边长多1，即如果该点左上的三个点有值为0的点，当前点所在的全为1的正方形最大边长只能为1，所以这时只能取另外三个正方形中最小的正方形边长+1。用d[i][j]表示以i，j坐标为右下角的正方形最大边。则有状态转移方程：dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1*/int res = 0;for ( i=0; i&lt;n; i++) &#123; if (matrix[i][0] == 1) &#123; dp[i][0] = 1; res = 1; &#125;&#125;for ( j=0; j&lt;n; j++) &#123; if (matrix[0][j] == 1) &#123; dp[0][j] = 1; res = 1; &#125;&#125;for ( i=1; i&lt;n; i++) &#123; for ( j=1; j&lt;n; j++) &#123; if (matrix[i][j] == 1) &#123; dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; &#125; res = max(res, dp[i][j]); &#125;&#125; 模板十 STL一、vector12345678910111213//定义一维数组vector&lt;int&gt; num;//定义另一个领接表vector&lt;int&gt; G[N];push_back(x);pop_back(); //删除尾部元素size(); //求元素个数insert(it,x) //迭代器it处插入xerase(it)erase(first, last) //左闭右开sort( v.begin(), v,end() ) //排序 默认从小到大排序sort( v.begin(), v.end(), greater&lt;int&gt;() ) //从大到小排序 二、string三、set12345678//定义一个setset&lt;int&gt; s;insert(x); //插入一个元素 自动递增驱虫排序find(value); //返回值为value的迭代器类型erase(it); //删除迭代器元素erase(value); //删除指定值元素erase( first, last ) //删除迭代器类型指定区间元素 左开右闭size(); //获取元素个数 四、queue12345678//定义一个队列queue&lt;int&gt; q;push(); //入队front(); //队首元素back(); //队尾元素pop(); //队首元素出队empty(); //判空size(); //队列元素个数 优先队列 12345678910111213//定义优先队列priority_queue&lt;int&gt; q;// 数字大的优先级大 数字大的在队首priority_queue&lt;int, &lt;vector&gt;, less&lt;int&gt; &gt; q;// 数字大的优先级大 数字小的在队首priority_queue&lt;int, &lt;vector&gt;, greater&lt;int&gt; &gt; q;//结构体优先级设置struct fruit&#123; int num; friend bool operator &lt; ( fruit a, fruit b ) return a.num &lt; b.num; //数字大的优先级大 数字大的在队首&#125; 五、algorithm1234max() min() abs()swap()reverse( it1, it2 ) //左闭右开reverse( A, A+A.size() ) //数组逆置 模板十一 其它算法一、递归1、从数组中取出n个元素的所有组合 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;//arr为原始数组//start为遍历起始位置//result保存结果，为一维数组//count为result数组的索引值，起辅助作用//NUM为要选取的元素个数//arr_len为原始数组的长度，为定值void combine_increase(int* arr, int start, int* result, int count, const int NUM, const int arr_len)&#123; int i = 0; for (i = start; i &lt; arr_len + 1 - count; i++) &#123; result[count - 1] = i; if (count - 1 == 0) &#123; int j; for (j = NUM - 1; j &gt;= 0; j--) printf("%d\t",arr[result[j]]); printf("\n"); &#125; else combine_increase(arr, i + 1, result, count - 1, NUM, arr_len); &#125;&#125;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6&#125;; int num = 4; int result[num]; combine_increase(arr, 0, result, num, num, sizeof(arr)/sizeof(int)); return 0;&#125; 二、回溯 1、求数组的全排列 123456789101112131415161718192021222324252627int n, P[maxn], HashTable[maxn] = &#123;false&#125;;void generateP(int index)&#123; if(index == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; P[i]; cout &lt;&lt; endl; return; &#125; for( int x = 1; x &lt;= n; x++ ) if( HashTable[x] == false ) &#123; P[index] = x; HashTable[x] = true; generateP( index+1 ); HashTable[x] = false; &#125;&#125;int main()&#123; n = 3; generateP(1); return 0;&#125; 2、八皇后问题 1234/*八皇后问题即使全排列问题, 找到不符合条件的全排列，即在同一条对角线的两个皇后同一对角线的条件为*/if( abs(i - j) == abs( p[i]-p[j] ) ) 三、枚举四、其他问题1、查找第K小数 12345678910111213141516171819202122232425262728293031323334353637383940/*此题可以用快排的思想找第K小数，也可以直接使用set 可以去重复*/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000;int num[maxn];int main() &#123; freopen( "in.txt", "r", stdin ); int n, k; cin &gt;&gt; n &gt;&gt; k; for( int i = 0; i &lt; n; i++ ) cin &gt;&gt; num[i]; k--; int pivot = num[0]; int low = 0, high = n-1; while( low &lt; high ) &#123; int low_temp = low; int high_temp = high; pivot = num[low]; while( low &lt; high ) &#123; while( num[high] &gt;= pivot &amp;&amp; low &lt; high ) high--; num[low] = num[high]; while( num[low] &lt;= pivot &amp;&amp; low &lt; high ) low++; num[high] = num[low]; &#125; num[low] = pivot; if( low &lt; k ) &#123; low++; high = high_temp; &#125; else if( low &gt; k ) &#123; high--; low = low_temp; &#125; else cout &lt;&lt; num[low] &lt;&lt; endl; &#125; return 0;&#125; ​]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>机试</tag>
      </tags>
  </entry>
</search>
