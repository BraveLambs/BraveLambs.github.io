<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2021%2F01%2F14%2F%E5%89%91%E6%8C%87Offer%2051%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[Hard | 剑指 Offer 51. 数组中的逆序对 | 归并排序在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 这道Hard题是很难想的。方法很巧妙, 我是看了题解看了好长时间才弄懂。 这道题的核心思想是 递归的把数据分成两半, 先计算左半边的逆序对, 再计算右半边的逆序对, 然后计算跨越左半边和右半边的逆序对。 计算逆序对的办法是归并排序。边排序, 边计算。并且在计算跨左右两边的逆序对 , 并且归并排序的同时, 有一个重要的前提是左右两边的逆序对已经计算完成了,并且已经是升序的。 下图1是递归分治的过程, 简单来说就是递归的归并排序算法 图2是归并排序并且计算逆序对的过程。首先是2和1比, 因为1小于2, 所以把1放入原始数据(代表已排好序)。由于(由于此时2和1构成逆序对)。根据归并的两个数组有序的特点, 一下了就可以得出, 在左边的数组当中, 与右边1构成逆序对的数是4。把这个过程画一画, 就能感受到时间的优化在哪里了。 总的时间复杂度为：O(nlogn）; 空间复杂度为O(n) 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public int reversePairs(int[] nums) &#123; int len = nums.length; // 如果没有数或者只有1个数字, 直接返回0 if (len &lt; 2) &#123; return 0; &#125; // copy 只是为了防止原数组被修改, 所以拷贝一个副本 int[] copy = Arrays.copyOf(nums, len); // temp 是归并排序的辅助数组 int[] temp = new int[len]; return reversePairs(copy, 0, len-1, temp); &#125; // 计算 [left, right] 的逆序对个数并且排序 public int reversePairs(int[] nums, int left, int right, int[] temp) &#123; if (left == right) &#123; return 0; &#125; int mid = left + ((right - left) &gt;&gt; 1); // 递归左半边归并排序, 并且计算左半边的逆序对 int leftPairs = reversePairs(nums, left, mid, temp); // 递归右半边归并排序, 并且计算右半边的逆序对 int rightPairs = reversePairs(nums, mid + 1, right, temp); // 优化 : 两边已经排好序时, 并且整个数组都已经有序时, 就不用再继续进行归并了 if (nums[mid] &lt;= nums[mid+1]) &#123; return leftPairs + rightPairs; &#125; // 归并左右的两个半边的数组, 并计算跨这个半边的逆序对的个数 int crossPairs = mergeAndCount(nums, left, mid , right, temp); // 逆序对总数是左半边逆序对的个数 + 右半边逆序对个数 + 跨越两个半边的逆序对总和。 return leftPairs + rightPairs + crossPairs; &#125; // 归并排序的具体过程 public int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123; // temp 是对 [left, mid] [mid + 1, right] 两个有序数组进行归并排序的辅助数组 for (int i = left; i &lt;= right; i++) &#123; temp[i] = nums[i]; &#125; int i = left, j = mid + 1; int count = 0; for (int k = left; k &lt;= right; k++) &#123; if (i == mid + 1) &#123; // 左边已经全部归并完成 nums[k] = temp[j++]; &#125; else if (j == right + 1) &#123; // 右边全部归并完成 nums[k] = temp[i++]; &#125; // 这里只有&lt;= 归并排序才是一个稳定的排序 else if (temp[i] &lt;= temp[j]) &#123; nums[k] = temp[i++]; &#125; else &#123; nums[k] = temp[j++]; // 逆序对是左边还没有归并的数 count += (mid - i + 1); &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hard | LeetCode 10 | 剑指 Offer 19. 正则表达式匹配]]></title>
    <url>%2F2021%2F01%2F14%2F%E5%89%91%E6%8C%87Offer%2010%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Hard | LeetCode 10 | 剑指 Offer 19. 正则表达式匹配 |递归| 动态规划请实现一个函数用来匹配包含&#39;. &#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。 方法一：递归维持两个指针sIndex, pIndex 分别指向主串和模式串, 从左往右比较。 如果pIndex指向的元素的下一个元素不是&#39;*&#39;, 则说明当前的模式串字符必须参与匹配, 且匹配一次, 然后继续匹配后面未匹配的字符。用代码语言表达为 1234567if (pIndex == p.length() - 1 || p.charAt(pIndex+1) != '*') &#123; // 下一个字符不是'*' if (sIndex &lt; s.length() &amp;&amp;(p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) =='.')) &#123; // 匹配主串和模式串后面的字符 return matchCore(s, sIndex + 1, p, pIndex + 1); &#125;&#125; 如果pIndex指向的元素的下一个元素是&#39;*&#39;, 则说明当前的pIndex元素可以参与匹配0次 或者参与匹配多次。 2.1 如果当前的pIndex元素参与匹配0次 , 那么当前的主串字符在下一次递归还是要参与匹配的, 而且对于模式串, 下一次递归里, 当前字符和下一个&#39;*&#39;都不参与匹配。用代码语言表达为return matchCore(s, sIndex, p, pIndex + 2); 2.2 如果当前的pIndex元素参与匹配, 可能1, 2,3,4… 多次。则当前主串字符在下一次递归就无需再匹配了, 因为当前的pIndex元素已经匹配了。如果是只匹配一次, 当前的模式串字符和下一个&#39;*&#39;号在下一次递归可以不匹配了, 但如果是2, 3, 4…等多次, 那么还是要在下一次递归继续使用。综合来讲, 可以写为matchCore(s, sIndex + 1, p, pIndex), 因为即使下一个&#39;*&#39;号只代表当前字符串出现1次, 把这个&#39;*&#39;号保留到下一次递归当中, 下一次递归如果不需要此字符, &#39;*&#39;号是可以代表当前当前字符出现0次的。所以将&#39;*&#39;代表前一个字符出现1, 2,3..等多次写成matchCore(s, sIndex + 1, p, pIndex)也是没有问题的。 前面1,2两点是递归的具体逻辑。而递归出口就比较容易想到了。 3.1 如果主串和模式串刚好全部匹配完, 自然返回true 3.2 如果模式串已经匹配完, 主串还没有匹配完, 那么返回false。 3.3 如果是主串已经全部匹配完, 模式串还没有匹配完, 那么这个时候是否能直接返回false呢？答案是不可以。反例就是：主串&quot;&quot;, 模式串a* 所以即找到了递归的关系(前面第1, 2点), 也找到了递归出口(前面第3点), 下面的代码自然就水到渠成了。 1234567891011121314151617181920212223242526272829303132333435363738public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; &#125; return matchCore(s, 0, p, 0); &#125;public boolean matchCore(String s, int sIndex, String p, int pIndex) &#123; if (sIndex == s.length() &amp;&amp; pIndex == p.length()) &#123; return true; &#125; // 模式串全部匹配完就会立即判断是否能够匹配 if ((sIndex &lt; s.length() &amp;&amp; pIndex == p.length())) &#123; return false; &#125; // 模式串的下一个不是 * , 或者模式串已经匹配到最后一个字符 的情况 if (pIndex == p.length() - 1 || p.charAt(pIndex+1) != '*') &#123; if (sIndex &lt; s.length() &amp;&amp; // 确保主串指针不能越界, 因为即使主串已经全部匹配完, 如果模式串还没有匹配, 还是要继续匹配的 (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == '.')) &#123; return matchCore(s, sIndex + 1, p, pIndex + 1); &#125; &#125; else &#123; // 模式串下一个是 * 的情况 // 当前模式串的字符, 能够匹配当前字符串字符 if (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == '.')) &#123; // 可以选择 * 匹配当前字符串字符1次或多次, 当前模式串字符还要继续匹配后面的字符串 return matchCore(s, sIndex + 1, p, pIndex) || // * 匹配当前字符串字符 0 次 matchCore(s, sIndex, p, pIndex + 2); &#125; else &#123; // 当前模式串字符 无法匹配 当前字符串字符 那么* 只能出现代表前面字符 0 次 return matchCore(s, sIndex, p, pIndex + 2); &#125; &#125; return false;&#125; 方法二： 动态规划既然是动态规划, 我首先给一个二维表格boolean[][] match = new boolean[s.length() + 1][p.length() + 1];其中match[i][j]代表从 主串i以及左边的字符串 与 模式串里j以及左边的字符串 能够匹配上。所以动态规划的递归关系就分为以下两种情况 如果当前字符不是&#39;*&#39;, 那么当前match值取决于 (1) 当前的主串和模式串的字符(单个) 是否能够匹配; (2) 如果能够匹配了, 还要看他们前面的那些字符是否能够匹配上, 使用代码语言表达为 123if (p.charAt(j-1) != '*') &#123; match[i][j] = matches(s, i, p, j) &amp;&amp; match[i-1][j-1];&#125; 其中判断某两个字符是否能够匹配的方法如下 , 注意, 在进行遍历的时候, 第一个字符的下标是从1开始里, 这里要相应的处理。 123456public boolean matches(String s, int i, String p, int j) &#123; if (i == 0) &#123; return false; &#125; return s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.';&#125; 如果当前字符是&#39;*&#39;。这种情况就要分两种情况讨论了。2.1 当前&#39;*&#39;字符的前一个字符出现次数为0, 那么当前的match[i][j]值, 完全等价于match[i][j-2], 这个应该很容易理解2.2 当前&#39;*&#39;字符的前一个字符出现次数不为0, 出现1, 2,3….等多次, 那么当前的match[i][j]值即取决于：(1) 当前主串的s[i]的值与模式串号前一个值p[j-1]的值是否能够匹配; (2) 主串前面的值 与 模式串前面的值(包含当前的`’‘`) 是否能够匹配。(至于为什么即使*表示前一个字符只出现1次, 比较前面的字符串 也要包含在内 ？ 原因和第一种递归里的方法一样, 在前一次匹配当中, 这里的*同样是可以代表前一个字符出现次数为0的)； 这两种情况用代码语言表达为： 12match[i][j] = match[i][j-2] || // * 的前一个字符匹配0次 (matches(s, i, p, j-1) &amp;&amp; match[i-1][j]); // * 的前一个字符匹配1次或者多次 动态规划的初始边界。 3.1 match[0][0] = true, 表示当主串和模式串都没有字符时, 为true。 3.2 循环遍历起始指针如下, 主串是从下标0开始的, 原因是即使主串没有字符, 模式串有字符, 比如主串：&quot;&quot;, 模式串&quot;a*&quot;, 这个时候match[0][1]和match[0][2] 都是true, 也是需要进行计算的。 12345for(int i = 0; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; // TODO 动态规划递推关系 &#125;&#125; 依据以上的递推关系和起始边界, 动态规则算法的代码如下： 12345678910111213141516171819202122232425public boolean isMatch(String s, String p) &#123; boolean[][] match = new boolean[s.length() + 1][p.length() + 1]; match[0][0] = true; for(int i = 0; i &lt;= s.length(); i++) &#123; for (int j = 1; j &lt;= p.length(); j++) &#123; if (p.charAt(j-1) != '*') &#123; // 当前字符不为 *, 比较当前字符是否能匹配, 以及前面的字符是否能匹配 match[i][j] = matches(s, i, p, j) &amp;&amp; match[i-1][j-1]; &#125; else &#123; // 当前字符为 * match[i][j] = match[i][j-2] || // * 的前一个字符匹配0次 (matches(s, i, p, j-1) &amp;&amp; match[i-1][j]); // * 的前一个字符匹配1次或者多次 &#125; &#125; &#125; return match[s.length()][p.length()];&#125;public boolean matches(String s, int i, String p, int j) &#123; if (i == 0) &#123; return false; &#125; // 匹配的条件: (1) 主串和模式串字符相等 (2) 模式串字符为'.', 可以匹配任意字符 return s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.';&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北邮机试模板]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8C%97%E9%82%AE%E6%9C%BA%E8%AF%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[​ 这是我在准备北邮上机考试时准备的模板，其中不少是来自北邮的历年机试真题，还有一部分来自PAT书。但是北邮网研今年不能携带纸质资料了，但还好今年题目简单。 ​ 北邮机试有它自己的特点，一般前两道题比较简单，一般就是简单的数学问题，进制问题，简单的字符串问题， 质数问题，打印图案等等。前两道题是比较容易轻松拿下的。后两道题有时候就会比较难的，树，图，搜索，并查集，贪心，DP，还有很恶心的字符串处理题目。其中树和图的模板性较强。但是我看过PAT书和王道书的模板都是严书数据结构类似。建议在这里使用全部使用数组存储，会容易很多。字符串的题目可以看看sscanf, 可以匹配正则表达式，用作提取字符串可谓一大神器，比stl模板库string还好用！！！ 上机模板： 模板一 打印素数表123456789101112131415161718192021222324/* PAT P161 */const int MAXNUM = 105000;const int maxn = 10010;bool prime[MAXNUM] = &#123;false&#125;;int p[maxn];int FindPrime()&#123; int index = 0; for(int i = 2; i &lt; MAXNUM; i++) &#123; //如果未标记则得到一个素数 if( !prime[i] ) p[index++] = i; //标记目前得到的素数的i倍为非素数 for( int j = 0; j &lt; index &amp;&amp; p[j] * i &lt; MAXNUM; j++ ) &#123; prime[i * p[j]] = true; if( i % p[j] == 0 ) break; &#125; &#125; return index;&#125; 1234567891011121314151617181920212223const int MAXNUM = 105000;const int maxn = 10010;bool prime[MAXNUM] = &#123;false&#125;;int p[maxn];bool isprime( int x )&#123; for( int i = 2; i &lt;= sqrt(x*1.0); i++ ) if( x % i == 0 ) return false; return true;&#125;int cursor = 0;void FindPrime()&#123; for( int i = 2; i &lt; MAXNUM; i++ ) if( isprime(i) ) &#123; prime[i] = true; p[cursor++] = i; &#125; &#125; 备注：写完这个函数一定要记得把FindPrime()写到主函数里面去！！！ 第 100个素数 = 541 第 1000个素数 = 7919 第10000个素数 = 104729 第20000个素数 = 224737 第30000个素数 = 350377 第40000个素数 = 479909 第50000个素数 = 611953 第60000个素数 = 746773 第70000个素数 = 882377 第80000个素数 = 1020379 模板二 大数一、基本函数： 1.valueOf(parament); 将参数转换为制定的类型 比如 int a = 3; BigInteger b = BigInteger.valueOf(a); 则b=3; String s= “12345”; BigInteger c = BigInteger.valueOf(s); 则c = 12345； 2.add(); 大整数相加 BigInteger a=new BigInteger(“23”); BigInteger b=new BigInteger(“34”); a.add(b) 3.subtract(); 相减 4.multiply(); 相乘 5.divide(); 相除取整 6.remainder(); 取余 7.pow(); a.pow(b)=a^b 8.gcd(); 最大公约数 9.abs(); 绝对值 10.negate(); 取反数 11.mod(); a.mod(b)=a%b=a.remainder(b); 12.max(); min(); 13.public int comareTo(); 14.boolean equals(); 是否相等 15.shiftLeft():左移，this &lt;&lt; n ，this*2^n; shiftRight():右移，this &gt;&gt; n，this/2^n; 16.bitLength：返回该数的最小二进制补码表示的位的个数，即 不包括 符号位 (ceil(log2(this &lt;0 ? -this : this + 1)))。对正数来说，这等价于普通二进制表示的位的个数。 17.bitCount：返回该数的二进制补码表示中不包扩符号位在内的位的个数。该方法在 BigIntegers 之上实现位向量风格的集合时很有用。 18.isProbablePrime：如果该 BigInteger 可能是素数，则返回 true ；如果它很明确是一个合数，则返回 false 。 参数 certainty 是对调用者愿意忍受的不确定性的度量：如果该数是素数的概率超过了 1 - 1/2**certainty方法，则该方法返回 true 。执行时间正比于参数确定性的值。 19.nextProbablePrime()：获取下一个可能的素数是多少 20.BigInteger构造函数： 一般用到以下两种： BigInteger(String val); 将指定字符串转换为十进制表示形式； BigInteger(String val,int radix); 将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger 二、注意 1.其构造方法有很多，常用的邮： BigInteger(String val) 将 BigInteger 的十进制字符串表示形式转换为 BigInteger。 BigInteger(String val, int radix)将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger。 2.进行数学运算时不能直接使用数学运算符进行运算，必须使用其内部方法。而且其操作数也必须为BigInteger型。 3.当要把计算结果输出时应该使用.toString方法将其转换为10进制的字符串：System.out.print(two.toString()); 三、进制转换 我最喜欢的功能，因为直接实现了算法，就不用我写了。可以使用以下函数，转换成字符串后如果存在abc等字符默认的是小写，如果转换成大写可以加上.toUpperCase()； 123private static String change(String num, int from, int to) &#123; return new BigInteger(num, from).toString(to);&#125; 四、案例 123456789101112131415161718192021222324252627282930313233import java.math.BigInteger;import java.util.Scanner;public class numNodeofAVL &#123; static int maxn = 100000; static BigInteger H[] = new BigInteger[maxn]; /** * @param args */ public static void main(String[] args) &#123; //int maxn = 100; //BigInteger H[] = new BigInteger[maxn]; H[1] = BigInteger.valueOf(1); H[2] = BigInteger.valueOf(2); int i = 3; while( i &lt; maxn ) &#123; H[i] = H[i-1].add( H[i-2]).add(H[1]); i++; &#125; Scanner cin = new Scanner( System.in ); System.out.print("请输入数据组数："); int T = cin.nextInt(); int n; while( T-- &gt; 0 )&#123; System.out.print("请输入一个整数："); n = cin.nextInt(); System.out.println( H[n] ); &#125; cin.close(); &#125;&#125; 模板三 表达式求值1/*PAT书 P247 简单计算器 */ 模板四 字符串一、字符串向整数映射( PAT实战 P352) 1234567891011121314map&lt;string, int&gt; stringToInt;map&lt;int, string&gt; intToString;int numList = 0;int change( string str )&#123; if( stringToInt.find(str) != stringToInt.end() ) return stringToInt[str]; else &#123; stringToInt[str] = numList; intToString[numList] = str; return numList++; &#125;&#125; 二、字符串输入 12345678/*输入T组一个带空格的字符串*/string str;int T;cin &gt;&gt; T; //不丢弃换行符getchar() //接受输入整数T后的空格while( T-- ) getline( cin, str ); //遇到换行符停止 并且丢弃换行符 1234string str;char c;while((c=cin.get())!='\n') str+=c; 三、去除字符串的空格 123456pos = find(" ");while( !(pos == string::npos || pos == -1) )&#123; str.erase( pos, 1 ); pos = str.find(" ") ;&#125; 四、十六进制转十进制 123456789101112131415int hexToDec( string str )&#123; int len = str.size(); int sum = 0; for( int i = 0; i &lt; len; i++ ) &#123; int num; if( isdigit(str[i]) ) num = str[i] - '0'; else num = str[i] -'a' + 10; sum = sum * 16 + num; &#125; return sum;&#125; 五、STL String类型(PAT P202) 1234567891011str1 += str2 //直接拼接字符串&lt; &gt; == //按字典序比较字符串size()/length() //z字符串长度insert( pos, str) //在pos处插入字符串strerase(it)erase(first, last) // 迭代器类型 左闭右开erase(pos,len) //int类型 指定类型及其长度substr(pos, len) //提取子串find(str) //返回str第一次出现的位置find(pos,str) //返回str在pos位置之后出现的位置replace(pos,len,str) //将起始位置为pos，长度为len的那部分替换为字符串str 六、例题 12345678910111213141516171819202122232425262728293031323334353637383940/**给出一句英文句子(只由大小写字母和空格组成，不含标点符号，也不会出现连续的空格),请将其中的所有单词顺序翻转**//// 没有多余空格 可以使用 cin 输入 自动跳过空格 并且将单词入栈。全部入栈后出栈即可#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;int main() &#123; stack&lt;string&gt; s; string str; bool firstcase; while( cin &gt;&gt; str ) &#123; //实现多组数据的输入 ///Initstack while( !s.empty() ) s.pop(); firstcase = true; ///Input while(1) &#123; s.push(str); /*因为 在cin 最后一个单词后 str被压入栈中 但是输入缓冲队列 还保存着 回车符 cin并不会丢弃回车符*/ if( getchar() == '\n') break; cin &gt;&gt; str; &#125; ///output while( !s.empty() ) &#123; if( firstcase ) firstcase = false; else cout &lt;&lt; " "; str = s.top(); cout &lt;&lt; str; s.pop(); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 模板五 树模板一、树的存储一、父亲孩子表示法12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#define maxsize 1010using namespace std;// 父亲孩子表示法( 同时记录双亲和孩子位置 )struct Node&#123; int data; /// 节点值 为 父节点 所在数组 下标 vector&lt;int&gt; sonList; ///根节点 data 值为 -1； bool turnOn; ///此二叉树节点是否有效 Node() &#123; initNode(); &#125; void initNode() &#123; turnOn = false; sonList.clear(); &#125;&#125;; 二、建树1234567891011121314151617181920212223242526Node Tree[maxsize]; ///用一维数组来存储一颗二叉树int createNode( int data, int index ) ///在数组下标 index 处创造一个节点&#123; Tree[index].data = data; Tree[index].turnOn = true; return index;&#125;void createTree( int N )&#123; /// Tree[]初始化 for( int i = 0; i &lt; maxsize; i++ ) Tree[i].initNode(); cursor = 0; int x,y; N--; /// 此树有N个节点,N-1条边 while( N-- ) &#123; cin &gt;&gt; x &gt;&gt; y; /// x 是 y 的父节点 if( Tree[x].turnOn == false ) /// X 节点没有创建 即 X 是根节点 createNode( -1, x ); Tree[x].sonList.push_back( y ); /// 创造节点后 记录孩子节点 if( Tree[y].turnOn == false ) createNode( x, y ); &#125;&#125; 三、删除树 1234567891011void freeNode( int index )&#123; Tree[index].initNode();&#125;void freeTree( int index ) ///采用递归的方式释放一棵树&#123; Node &amp;nowp = Tree[index]; for( int i = 0; i &lt; nowp.sonList.size(); i++ ) freeTree( nowp.sonList[i] );&#125; 四、二叉树的存储和求深度与层次遍历12345678910111213141516171819typedef struct BiNode&#123; int data; int lc; ///左孩子的数组下标 int rc; ///右孩子的数组下标 int deep; bool turnOn; ///此二叉树节点是否有效 BiNode() &#123; initNode(); &#125; void initNode() &#123; turnOn = false; deep = -1; lc = rc = -1; &#125;&#125;; 五、二叉树的建立与删除12345678910111213141516171819202122232425262728293031323334353637383940414243BiNode Tree[maxsize]; ///用一维数组来存储一颗二叉树int cursor;int t, n, m;int createNode( int index ) ///在数组下标 x 处创造一个节点&#123; Tree[index].data = index; Tree[index].turnOn = true; Tree[index].lc = Tree[index].rc = -1; return index;&#125;void creatTree()&#123; int a,b; /// a 的 父节点是 b; createNode(0); ///创建根节点 cin &gt;&gt; n &gt;&gt; m; /// n 行 m 个 节点 while( n-- ) &#123; cin &gt;&gt; a &gt;&gt; b; a--; b--; createNode( a ); ///创建 a 节点 if( Tree[b].lc == -1 ) /// 无座孩子 先写入左孩子 Tree[b].lc = a; else Tree[b].rc = a; &#125;&#125;void freeNode( int index )&#123; Tree[index].initNode();&#125;void freeTree( int index ) ///采用递归的方式释放一棵树( 后序方式 ）&#123; if( index == -1 ) /// 递归出口 return; freeTree( Tree[index].lc ); ///递归删除左子树 freeTree( Tree[index].rc ); ///递归删除右子树 Tree[index].initNode(); ///删除根节点&#125; 六、二叉树计算深度与层次遍历123456789101112131415161718192021222324252627282930313233343536373839void calDeep( int root, int nowDeep ) ///先序递归方式求出各节点所在的层次&#123; if( root == -1 ) return; Tree[root].deep = nowDeep; calDeep( Tree[root].lc, nowDeep+1 ); calDeep( Tree[root].rc, nowDeep+1 );&#125;void levelOrder( int root ) ///从第 nowDeep 层开始 非递归的层次遍历root 为根节点的二叉树&#123; bool firstCase = true; int nowDeep = 1; queue&lt;BiNode&gt; q; while( !q.empty() ) ///队列初始化 q.pop(); q.push( Tree[root] ); ///根节点入队 while( !q.empty() ) &#123; BiNode &amp;nowNode = q.front(); q.pop(); if( nowNode.deep != nowDeep ) ///到了下一层 &#123; cout &lt;&lt; endl; nowDeep++; firstCase = true; &#125; if( firstCase ) firstCase = false; else cout &lt;&lt; " "; ///从if到这里 按层打印 cout &lt;&lt; nowNode.data+1; ///访问节点 if( nowNode.lc != -1 ) q.push( Tree[nowNode.lc] ); if( nowNode.rc != -1 ) q.push( Tree[nowNode.rc] ); &#125;&#125; 七、树的双亲表示法( 并查集模板)可解决问题：求两个节点的最近公共祖先( 2014-软件-C) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;stack&gt;#define MAXSIZE 500using namespace std;struct Set&#123; ///并查集模板 int root[MAXSIZE]; int setSize; int initSet( int setSize ) &#123; this -&gt; setSize = setSize; for(int i = 0; i &lt; setSize; i++ ) root[i] = -1; &#125; int FindRoot( int v, stack&lt;int&gt; &amp;s ) &#123; s.push(v); while( root[v] != -1 ) &#123; v = root[v]; s.push(v); &#125; return v; &#125;&#125;;int main()&#123; int T, N, M; scanf( "%d", &amp;T ); Set set; stack&lt;int&gt; fa1, fa2; int u, v; int i, j; for( i = 0; i &lt; T; i++ ) &#123; scanf("%d", &amp;N ); set.initSet( N ); for( j = 0; j &lt; N-1; j++ ) &#123; scanf( "%d%d", &amp;u, &amp;v ); u--; v--; set.root[v] = u; &#125; scanf("%d", &amp;M); for( j = 0; j &lt; M; j++ ) &#123; while( !fa1.empty() ) fa1.pop(); while( !fa2.empty() ) fa2.pop(); scanf( "%d%d", &amp;u, &amp;v ); u--; v--; //边找根边将所有祖先入栈 set.FindRoot( u, fa1 ); set.FindRoot( v, fa2 ); int root1 = 1, root2 = 1, LCA; while( !fa1.empty() &amp;&amp; !fa2.empty() ) &#123; root1 = fa1.top(); root2 = fa2.top(); fa1.pop(); fa2.pop(); if( root1 == root2 ) LCA = root1; else break; &#125; printf("%d\n", LCA+1 ); &#125; &#125;&#125; 八、例题 1、13-网研-D-文件系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxsize = 101;struct Node&#123; string name; int data; vector&lt;int&gt; sub; Node() &#123; initnode(); &#125; void initnode() &#123; data = -1; sub.clear(); &#125;&#125;;Node Tree[maxsize];int cursor = 0;void createnode(string str1, string str2, int type)&#123; int i; Tree[cursor].name = str1; Tree[cursor].data = type; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str2 ; i++ ); Tree[i].sub.push_back(cursor++);&#125;int main()&#123; int T, N; cin &gt;&gt; T; string command, str1, str2; while( T-- ) &#123; for( int i = 0; i &lt; maxsize; i++ ) Tree[i].initnode(); cursor = 0; Tree[0].data = 1; Tree[0].name = "root"; cursor++; int i, j; cin &gt;&gt; N; while( N-- ) &#123; cin &gt;&gt; command; if( command == "CREATEFILE" ) &#123; cin &gt;&gt; str1 &gt;&gt; str2; createnode( str1, str2, 0 ); &#125; else if( command == "CREATEDIR" ) &#123; cin &gt;&gt; str1 &gt;&gt; str2; createnode( str1, str2, 1 ); &#125; else if( command == "LISTFILE" ) &#123; cin &gt;&gt; str1; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str1; i++ ); for( j = 0; j &lt; Tree[i].sub.size(); j++ ) if( !Tree[Tree[i].sub[j]].data ) cout &lt;&lt; Tree[Tree[i].sub[j]].name &lt;&lt; endl; &#125; else if( command == "LISTDIR" ) &#123; cin &gt;&gt; str1; for( i = 0; i &lt; cursor &amp;&amp; Tree[i].name != str1; i++ ); for( j = 0; j &lt; Tree[i].sub.size(); j++ ) if( Tree[Tree[i].sub[j]].data ) cout &lt;&lt; Tree[Tree[i].sub[j]].name &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 二、树的操作1、数的最大深度及其个数( 普通树的孩子表示法 )123456789101112131415161718int maxdep = 0;int maxdep_cnt = 0;void DFS( int root, int dep )&#123; if( !Tree[root].child.size() ) &#123; if( dep &gt; maxdep ) &#123; maxdep = dep; maxdep_cnt = 1; &#125; else if( dep == maxdep ) maxdep_cnt++; return; &#125; for( int i = 0; i &lt; Tree[root].child.size(); i++ ) DFS( Tree[root].child[i], dep+1 );&#125; 2、先序中序求后序1234567891011121314151617bool firstCase = true;void toPost( int prel, int prer, int inl, int inr )&#123; int i; for( i = inl; i &lt;= inr &amp;&amp; in[i] != pre[prel]; i++ ); int llen = i - inl; int rlen = inr - i; if( llen ) toPost( prel+1, prel+llen, inl, i-1 ); if( rlen ) toPost( prer-rlen+1, prer, i+1, inr ); if( firstCase ) firstCase = false; else cout &lt;&lt; " "; cout &lt;&lt; pre[prel];&#125; 3、中序后序求先序12345678910111213void preorder( int poststart, int postend, int instart, int inend )&#123; cout &lt;&lt; post[postend] &lt;&lt; " "; ///根据后序序列打印 根节点 int i; for( i = instart; i &lt;= inend &amp;&amp; post[postend] != in[i]; i++ ); int llen = i - instart; ///左子树长度 int rlen = inend - i; ///右子树长度 if( llen ) preorder( poststart, poststart + llen - 1, instart, i-1 ); if( rlen ) preorder( postend - rlen, postend-1, i+1, inend ); return;&#125; 4、后序中序建树1234567891011121314int createTree( int poststart, int postend, int instart, int inend )&#123; int root = post[postend]; createNode( root ); ///根据后序序列创建 根节点 int i; for( i = instart; i &lt;= inend &amp;&amp; post[postend] != in[i]; i++ ); int llen = i - instart; ///左子树长度 int rlen = inend - i; ///右子树长度 if( llen ) BiTree[root].lc = createTree( poststart, poststart + llen - 1, instart, i-1 ); if( rlen ) BiTree[root].rc = createTree( postend - rlen, postend-1, i+1, inend ); return root; ///返回后序根节点&#125; 三、二叉排序树1、给定数字 排成完全二叉排序树12345678910111213const int maxn = 1000;int num[maxn], CBT[maxn];int index = 0;int N;void inorder( int root )&#123; if( root &gt; N ) return; inorder( 2*root ); CBT[root] = num[index++]; inorder( 2*root+1);&#125; 2、给定树型 排成二叉排序树123456789101112BiNode BST[maxn];int num[maxn];int index = 0;void inorder( int root )&#123; if( root == -1 ) return; inorder( BST[root].lc ); BST[root].data = num[index++]; inorder( BST[root].rc );&#125; 3、按给定序列一次插入构建二叉排序树12345678910111213141516171819202122232425int index = 0;void Insert( int data )&#123; if( index == 0 ) //插入第一个节点 &#123; Tree[index++].data = data; return; &#125; int root = 0; int parent = -1; Tree[index].data = data; //插入节点 while( root != -1 ) //找s父节点 &#123; parent = root; if( data &lt; Tree[root].data ) root = Tree[root].lc; else if( data &gt; Tree[root].data ) root = Tree[root].rc; &#125; if( data &lt; Tree[parent].data ) Tree[parent].lc = index; else if( data &gt; Tree[parent].data ) Tree[parent].rc = index; index++;&#125; 四、哈夫曼树1234567891011121314151617181920/*哈夫曼树带权路径和为所有节点和( 包括非叶节点 )*/#include&lt;queue&gt;priority_queue&lt;int , vector&lt;int&gt;, greater&lt;int&gt; &gt; Q; //建立一个小顶堆int calWPL()&#123; int ans=0; while(Q.size()&gt;1) //Q 的初始值为各个节点的值 &#123; int a=Q.top(); Q.pop(); int b=Q.top(); Q.pop(); ans+=a+b; Q.push(a+b); &#125; return ans;&#125; 模板六 图模板一、图的存储1、邻接矩阵 1234567891011int G[maxn][maxn] = &#123;0&#125;;int dist[maxn][maxn] = &#123;0&#125;;bool visit[maxn] = &#123;false&#125;;//建图while( M-- )&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u][v] += w; G[v][u] += w;&#125; 2、领接表 123456789101112///定义一个领接表vector&lt;int&gt; G[MAXSIZE];///设置访问标记数组bool visit[MAXSIZE] = &#123;0&#125;;//输入边建图while( M-- )&#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back( v ); G[v].push_back( u ); Union( u, v );&#125; 二、弗洛伊德算法1234567891011121314151617181920212223const int maxv = 50;int dist[maxv][maxv];int vertex[maxv][maxv];///弗洛伊德算法void Floyd( int n )&#123; int i, j, k; ///Initiate for( i = 0; i &lt; n; i++ ) for( j = 0; j &lt; n; j++ ) if( vertex[i][j] ) dist[i][j] = vertex[i][j]; else dist[i][j] = n; for(k = 0; k &lt; n; k++ ) for( i = 0; i &lt; n; i++ ) for( j = 0; j &lt; n; j++ ) if( dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j];&#125; 三、Dijkstra算法( 堆优化 )12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxn = 1010;const int INF = 0x3f3f3f3f; //无穷大int G[maxn][maxn] = &#123;0&#125;;int via[maxn] = &#123;0&#125;;int N, M, K;///Dijkstra最短路径算法int dist[maxn][maxn] = &#123;0&#125;;bool visit[maxn] = &#123;false&#125;;///优先队列int cur;struct cmp&#123; bool operator () (int a,int b)&#123; return dist[cur][a]&gt;dist[cur][b]; &#125;&#125;;priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; pq;void Dijkstra( int u )&#123; int mincost; cur = u; memset( visit, false, N+1 ); dist[u][u] = 0; while( !pq.empty() ) pq.pop(); pq.push( u ); while( !pq.empty() ) &#123; mincost = pq.top(); pq.pop(); if( visit[mincost] ) continue; visit[mincost] = true; for( int i = 0; i &lt;= N; i++ ) if( G[mincost][i] &amp;&amp; !visit[i] &amp;&amp; dist[u][i] &gt;= dist[u][mincost] + G[mincost][i] ) &#123; dist[u][i] = dist[u][mincost] + G[mincost][i]; pq.push( i ); &#125; &#125;&#125; 四、经过若干中间节点的最短路径123456789101112131415161718192021222324252627282930313233343536373839404142434445int main()&#123; int T; cin &gt;&gt; T; int N, M, K; int u, v, w; while( T-- ) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; memset( G, 0, sizeof(G) ); memset( dist, INF, sizeof(dist) ) //邻接矩阵建图 while( M-- ) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u][v] += w; G[v][u] += w; &#125; //计算各个中间节点到其他节点的单源最短路径 for( int i = 0; i &lt; K; i++ ) &#123; cin &gt;&gt; via[i]; Dijkstra( via[i] ); &#125; int shortpath = INF; Dijkstra(1); //核心代码 sort( via, via+K ); do &#123; int temppath = dist[1][via[0]]; for( int i = 0; i &lt; K-1; i++ ) &#123; int u = via[i]; int v = via[i+1]; temppath += dist[u][v]; &#125; if( temppath &lt; shortpath ) shortpath = temppath; &#125;while( next_permutation( via, via+K )); cout &lt;&lt; shortpath &lt;&lt; endl; &#125; return 0;&#125; 五、多条最短路径最优算法（ PAT实战 P369 ）方法一、修改Dijkstra( PAT P388) 方法二、Dijkstra 保存路径 DFS( PAT P389) 六、无环图找根使树高最大1、从某一定点 u 出发DFS找最深节点集合 123456789101112131415161718int maxH = 0;set&lt;int&gt; temp, A, B; //使用set类型是因为方便做并集运算bool visit[MAXSIZE] = &#123;0&#125;;void DFS( int u, int Height )&#123; visit[u] = true; if( Height &gt; maxH ) &#123; temp.clear(); temp.insert( u ); maxH = Height; &#125; else if( Height == maxH ) temp.insert( u ); for( int i = 0; i &lt; G[u].size(); i++ ) if( !visit[G[u][i]] ) DFS( G[u][i], Height+1 );&#125; 2、从上最深顶点任选一顶点进行DFS找最深节点集合 3、最大深度跟集合为两集合的并集 主函数代码如下 1234567891011121314151617181920212223int main()&#123; int N, M; cin &gt;&gt; N; M = N-1; int u, v; while( M-- ) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back( v ); G[v].push_back( u ); &#125; DFS( 1, 1 ); A = temp; memset( visit, false, sizeof(visit) ); DFS( *A.begin(), 1 ); B = temp; for( set&lt;int&gt;::iterator it = B.begin(); it != B.end(); it++ ) A.insert( *it ); for( set&lt;int&gt;::iterator it = A.begin(); it != A.end(); it++ ) cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 七、无环图找根中序遍历 12345678910111213141516171819202122232425bool visit[maxsize] = &#123;false&#125;;void inorder( int root )&#123; visit[root] = true; int i; // 找到第一个未被标记的孩子 即为左子树 遍历玩此左子树 就推出循环 for( i = 0; i &lt; vertex[root].size(); i++ ) &#123; int lc = vertex[root][i]; if( !visit[lc] ) &#123; inorder( lc ); break; &#125; &#125; temp.push_back( data[root] ); //访问根节点 int sonsize = vertex[root].size(); //上述 i 指向第一个左孩子 接下来依次遍历每个右孩子 for( i = i+1; i &lt; sonsize; i++ ) &#123; int rc = vertex[root][i]; if( !visit[rc] ) inorder( rc ); &#125;&#125; 八、DFS同时遍历点集和边集( PAT实战 P350 )1234567891011121314151617void DFS( int now, int &amp;head, int &amp;numMember, int &amp;totalValue )&#123; visit[now] = true; numMember++; if( weight[now] &gt; weight[head] ) head = now; for( int i = 0; i &lt; numPerson; i++ ) &#123; if( G[now][i] ) &#123; totalValue += G[now][i]; G[now][i] = G[i][now] = 0; //删除从 now 到 i 的边 if( !visit[i] ) DFS( i, head, numMember, totalValue ); &#125; &#125;&#125; 九、边权最小 点权最大( PAT实战360 )模板七 搜索一、DFS求连通块例题一、2014-计算机一- C -图像识别 我们将给定一幅N x M的图像，其中每个1 x 1的点都用一个[0,255]的值来表示他的RGB颜色。如果两个相邻的像素点颜色差不超过D，我们就认为这两个像素点属于同一个区域。对于一个像素点(x,y) ，以下这8个点（如果存在）是与它相邻的：（x-1, y-1），（x-1,y），（x-1,y+1），（x,y-1），（x,y+1），（x+1,y-1），（x+1,y），（x+1,y+1）。即 你的任务是写一个程序，分辨出给定图像中一共被分为多少个区域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 101;int data[maxn][maxn] = &#123;0&#125;;bool visit[maxn][maxn] = &#123;0&#125;;//8个方向的坐标遍历技巧int adjx[8] = &#123; -1, -1, -1, 0, 0, 1, 1, 1 &#125;;int adjy[8] = &#123; -1, 0, 1, -1, 1, -1, 0, 1 &#125;;int N, M, D;//判断是否能够到达下一个点 即图中两点之间是否相邻bool isdomain( int x1, int y1, int x2, int y2 )&#123; if( x2 &gt;= N || y2 &gt;= M || x2 &lt; 0 || y2 &lt; 0 || visit[x2][y2] ) return false; if( abs( data[x1][y1] - data[x2][y2] ) &gt; D ) return false; else return true;&#125;//深度优先遍历void DFS( int x, int y )&#123; visit[x][y] = true; for( int i = 0; i &lt; 8; i++ ) &#123; int newx = x + adjx[i]; int newy = y + adjy[i]; if( isdomain( x, y, newx, newy ) ) DFS( newx, newy ); &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while( T-- ) &#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; D; for( int i = 0; i &lt; N; i++ ) for( int j = 0; j &lt; M; j++ ) &#123; cin &gt;&gt; data[i][j]; visit[i][j] = false; &#125; int domain = 0; for( int i = 0; i &lt; N; i++ ) for( int j = 0; j &lt; M; j++ ) if( !visit[i][j] ) &#123; DFS( i, j ); domain++; &#125; cout &lt;&lt; domain &lt;&lt; endl; &#125; return 0;&#125; 二、并查集(PAT P334)1234567891011121314151617181920212223242526272829303132333435const int MAXSIZE = 1010;///并查集模板int father[MAXSIZE];int initSet( int setSize )&#123; for(int i = 0; i &lt; setSize; i++ ) &#123; father[i] = -1; visit[i] = 0; &#125;&#125;int FindRoot( int v )&#123; int u = v; while( father[v] != -1 ) v = father[v]; //路径压缩 while( father[u] != -1 ) &#123; int z = u; u = father[u]; father[z] = v; &#125; return v;&#125;void Union( int a, int b )&#123; int faA = FindRoot( a ); int faB = FindRoot( b ); if( faA != faB ) father[faB] = faA;&#125; 一、计算集合个数 1234567891011int isRoot[MAXSIZE] = &#123;0&#125;;int calBlock( int n )&#123; int block = 0; for( int i = 1; i &lt;= n; i++ ) isRoot[FindRoot(i)] = true; for( int i = 1; i &lt;= n; i++ ) if( isRoot[i] ) block++; return block;&#125; 二、例题（PAT实战P330） 有N个人，每个人喜欢若干项活动，如果两个人有任意一个喜欢的活动相同，那这两人同属一个社交网络。求N个人总共形成了多少了社交网络 1、判断两个人是否是同一个社交网络 12345678910111213int hobby[MAXSIZE] = &#123;0&#125;; //hobby[act]表示存储喜欢活动act的人的编号for( int i = 1; i &lt;= N; i++ ) //hobby 即为father数组&#123; //初始为0； 第一个喜欢该活动act的人为编号 scanf("%d:", &amp;amount); //后来的把自己和搞活动的并入 while( amount-- ) &#123; scanf( "%d", &amp;act ); if( !hobby[act] ) hobby[act] = i; else Union( hobby[act], i ); &#125;&#125; 模板八 矩阵问题一、矩阵乘法 1234567891011void mulmatrix()&#123; for( int i = 0; i &lt; n; i++ ) for( int j = 0; j &lt; n; j++ ) &#123; int sum = 0; for( int k = 0; k &lt; n; k++ ) sum += A[i][k] * B[k][j]; temp[i][j] = sum; &#125;&#125; 二、矩阵旋转 1、n x n 矩阵原地旋转 12345678910111213void rotate &#123; for(int i=0; i&lt;n/2; i++)&#123; for(int j=i; j&lt;n-1-i; j++)&#123; int temp = matrix[i][j]; matrix[i][j]=matrix[n-1-j][i]; matrix[n-1-j][i]=matrix[n-1-i][n-1-j]; matrix[n-1-i][n-1-j]=matrix[j][n-1-i]; matrix[j][n-1-i]=temp; &#125; &#125; &#125; &#125; 2、m x n 矩阵借助辅助矩阵旋转 1234567891011void rotate()&#123; int i, j; for( i = 0; i &lt; row; i++ ) for( j = 0; j &lt; col; j++ ) temp[j][row-i-1] = martrix[i][j]; swap( row, col ); for( i = 0; i &lt; row; i++ ) for( j = 0; j &lt; col; j++ ) martrix[i][j] = temp[i][j];&#125; 三、矩阵的Zigzag排列 1234567891011121314151617181920212223/*有四个方向。右、左下、下、右上。左下和右上可以继续，其他的方向需要改变成下一个。*/int dir[4][2] = &#123;&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;-1,1&#125;&#125;; //四个方向int m,n;vector&lt;int&gt; res;vector&lt;vector&lt;bool&gt; &gt; vis; //访问标记vector&lt;vector&lt;int&gt; &gt; matrixvoid dfs( int x,int y,int d )&#123; int cur_x,cur_y; cur_x=x+dir[d][0],cur_y=y+dir[d][1]; if(cur_x&gt;=0&amp;&amp;cur_x&lt;m&amp;&amp;cur_y&gt;=0&amp;&amp;cur_y&lt;n&amp;&amp;!vis[cur_x][cur_y])&#123; res.push_back(matrix[cur_x][cur_y]); vis[cur_x][cur_y] = true; if(d&amp;1) // d为斜方向 dfs(matrix,cur_x,cur_y,d); dfs( cur_x,cur_y,(d+1)%4); dfs( cur_x,cur_y,(d+2)%4); dfs( cur_x,cur_y,(d+3)%4); //其他方向都不行，只能顺着一个方向 dfs( cur_x,cur_y,d); &#125;&#125; 四、螺旋矩阵 同zigzag排列相识，定义四个方向 做访问标记数组判断 五、接雨水 123输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6记录每个位置往左边能到的最大值和往右边能到的最大值（里面选一个小的减去当前高度）就是这个位置能接的水，然后把所有位置能接的水加起来即为结果。 六、排序矩阵中的从小到大第k个数 每一行递增，每一列也递增。 把所有的元素排序，找第k个，这样的复杂度是O（n*logn） 而题目的挑战是O(k*logn)。 我们使用最小堆（优先队列）来实现，每次把元素的右边和下边的元素入队（比当前元素大一点点）。其实入队的操作就是在调整最小堆。【最小堆的实现使用数组vector】 模板九 DP一、最长连续子序列求数组 A[0], A[1] …A[n-1] 的最大连续子序列和。 123456789101112/* dp[0] = A[0];对于下标1...n的元素，以其为结尾的序列最大和为 前 i-1 个元素的最大和在加上自身， 自身的比较即如果 前i-1 个元素和大于0 则此元素附在前 i-1 个序列之后， 否则 自己单开一个序列。*/dp[0] = A[0];for( int i =1; i &lt; n-1; i++ )&#123; if( dp[i-1] &gt; 0 ) dp[i] = dp[i-1] + A[i]; else dp[i] = A[i];&#125; 二、最长连续不下降子序列( LIS )求数组 A[1], A[2] …A[n] 的非递减子序列的最大长度( 可以不连续 )。 123456789101112/*先让每个元素自成一个子序列 长度为1i 从 1 到 n 依次计算 以A[i]结尾的LIS计算的方法是 枚举从 1 到 i的元素 A[j] 判断A[i]接在A[j]后面能够更大 更新A[i] */int ans = -1;for( int i = 1; i &lt;= n; i++ )&#123; dp[i] = 1; for( int j = 1; j &lt; i; j++ ) if( A[i] &gt;= A[j] &amp;&amp; dp[j]+1 &gt; dp[i] ) dp[i] = dp[j]+1; ans = max( dp[i], ans );&#125; 三、最长公共子序列四、最大回文串五、背包一、Leetcode—221.Maximal Square 12345678910111213141516171819202122232425262728/*以矩阵中每一个点作为正方形右下角点来处理，当该点为1时，以该点为右下角点的最大边长最多比以它的左方、上方和左上方为右下角的正方形边长多1，即如果该点左上的三个点有值为0的点，当前点所在的全为1的正方形最大边长只能为1，所以这时只能取另外三个正方形中最小的正方形边长+1。用d[i][j]表示以i，j坐标为右下角的正方形最大边。则有状态转移方程：dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1*/int res = 0;for ( i=0; i&lt;n; i++) &#123; if (matrix[i][0] == 1) &#123; dp[i][0] = 1; res = 1; &#125;&#125;for ( j=0; j&lt;n; j++) &#123; if (matrix[0][j] == 1) &#123; dp[0][j] = 1; res = 1; &#125;&#125;for ( i=1; i&lt;n; i++) &#123; for ( j=1; j&lt;n; j++) &#123; if (matrix[i][j] == 1) &#123; dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; &#125; res = max(res, dp[i][j]); &#125;&#125; 模板十 STL一、vector12345678910111213//定义一维数组vector&lt;int&gt; num;//定义另一个领接表vector&lt;int&gt; G[N];push_back(x);pop_back(); //删除尾部元素size(); //求元素个数insert(it,x) //迭代器it处插入xerase(it)erase(first, last) //左闭右开sort( v.begin(), v,end() ) //排序 默认从小到大排序sort( v.begin(), v.end(), greater&lt;int&gt;() ) //从大到小排序 二、string三、set12345678//定义一个setset&lt;int&gt; s;insert(x); //插入一个元素 自动递增驱虫排序find(value); //返回值为value的迭代器类型erase(it); //删除迭代器元素erase(value); //删除指定值元素erase( first, last ) //删除迭代器类型指定区间元素 左开右闭size(); //获取元素个数 四、queue12345678//定义一个队列queue&lt;int&gt; q;push(); //入队front(); //队首元素back(); //队尾元素pop(); //队首元素出队empty(); //判空size(); //队列元素个数 优先队列 12345678910111213//定义优先队列priority_queue&lt;int&gt; q;// 数字大的优先级大 数字大的在队首priority_queue&lt;int, &lt;vector&gt;, less&lt;int&gt; &gt; q;// 数字大的优先级大 数字小的在队首priority_queue&lt;int, &lt;vector&gt;, greater&lt;int&gt; &gt; q;//结构体优先级设置struct fruit&#123; int num; friend bool operator &lt; ( fruit a, fruit b ) return a.num &lt; b.num; //数字大的优先级大 数字大的在队首&#125; 五、algorithm1234max() min() abs()swap()reverse( it1, it2 ) //左闭右开reverse( A, A+A.size() ) //数组逆置 模板十一 其它算法一、递归1、从数组中取出n个元素的所有组合 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;//arr为原始数组//start为遍历起始位置//result保存结果，为一维数组//count为result数组的索引值，起辅助作用//NUM为要选取的元素个数//arr_len为原始数组的长度，为定值void combine_increase(int* arr, int start, int* result, int count, const int NUM, const int arr_len)&#123; int i = 0; for (i = start; i &lt; arr_len + 1 - count; i++) &#123; result[count - 1] = i; if (count - 1 == 0) &#123; int j; for (j = NUM - 1; j &gt;= 0; j--) printf("%d\t",arr[result[j]]); printf("\n"); &#125; else combine_increase(arr, i + 1, result, count - 1, NUM, arr_len); &#125;&#125;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5, 6&#125;; int num = 4; int result[num]; combine_increase(arr, 0, result, num, num, sizeof(arr)/sizeof(int)); return 0;&#125; 二、回溯 1、求数组的全排列 123456789101112131415161718192021222324252627int n, P[maxn], HashTable[maxn] = &#123;false&#125;;void generateP(int index)&#123; if(index == n+1) &#123; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; P[i]; cout &lt;&lt; endl; return; &#125; for( int x = 1; x &lt;= n; x++ ) if( HashTable[x] == false ) &#123; P[index] = x; HashTable[x] = true; generateP( index+1 ); HashTable[x] = false; &#125;&#125;int main()&#123; n = 3; generateP(1); return 0;&#125; 2、八皇后问题 1234/*八皇后问题即使全排列问题, 找到不符合条件的全排列，即在同一条对角线的两个皇后同一对角线的条件为*/if( abs(i - j) == abs( p[i]-p[j] ) ) 三、枚举四、其他问题1、查找第K小数 12345678910111213141516171819202122232425262728293031323334353637383940/*此题可以用快排的思想找第K小数，也可以直接使用set 可以去重复*/#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1000;int num[maxn];int main() &#123; freopen( "in.txt", "r", stdin ); int n, k; cin &gt;&gt; n &gt;&gt; k; for( int i = 0; i &lt; n; i++ ) cin &gt;&gt; num[i]; k--; int pivot = num[0]; int low = 0, high = n-1; while( low &lt; high ) &#123; int low_temp = low; int high_temp = high; pivot = num[low]; while( low &lt; high ) &#123; while( num[high] &gt;= pivot &amp;&amp; low &lt; high ) high--; num[low] = num[high]; while( num[low] &lt;= pivot &amp;&amp; low &lt; high ) low++; num[high] = num[low]; &#125; num[low] = pivot; if( low &lt; k ) &#123; low++; high = high_temp; &#125; else if( low &gt; k ) &#123; high--; low = low_temp; &#125; else cout &lt;&lt; num[low] &lt;&lt; endl; &#125; return 0;&#125; ​]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>机试</tag>
      </tags>
  </entry>
</search>
